<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tf.data实例]]></title>
    <url>%2F2021%2F11%2F28%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2Ftf.data%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[使用tf.data作为数据输入训练模型 tf.data数据处理一维数据1234dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8])datasetfor ele in dataset: print(ele) 二维数据1234dataset = tf.data.Dataset.from_tensor_slices([[1,2],[3,4],[5,6],[7,8]])datasetfor ele in dataset: print(ele.numpy()) 字典1234567dataset = tf.data.Dataset.from_tensor_slices(&#123; &apos;a&apos; : [1,2,3,4], &apos;b&apos; : [3,4,1,2]&#125;)datasetfor ele in dataset: print(ele.get(&quot;a&quot;)) 使用numpy生成数组123456789dataset = tf.data.Dataset.from_tensor_slices(np.array([1,2,3,4,5]))dataset = dataset.shuffle(5)#打乱数据dataset = dataset.repeat(5)#重复扩展数据5次dataset = dataset.batch(5)#将数据分成5个batchdataset = dataset.map(tf.square)#将每个tensor开方for ele in dataset: print(ele.numpy())for ele in dataset: print(ele) 训练数据集使用numpy 处理数据免去使用tf api定义batchSize和训练数据 12345678910111213141516171819202122232425262728293031import tensorflow as tfimport numpy as np# 加载数据集(train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.mnist.load_data()train_images = train_images/255.0test_images = test_images/255.0ds_train_images = tf.data.Dataset.from_tensor_slices(train_images)ds_train_labels = tf.data.Dataset.from_tensor_slices(train_labels)ds_train = tf.data.Dataset.zip((ds_train_images, ds_train_labels))# 将两个数据集合并可以用zip()函数ds_train = ds_train.shuffle(10000).repeat().batch(32)# 创建test数据集ds_test_images = tf.data.Dataset.from_tensor_slices(test_images)ds_test_labels = tf.data.Dataset.from_tensor_slices(test_labels)ds_test = tf.data.Dataset.zip((ds_test_images, ds_test_labels))ds_test = ds_test.batch(32)model = tf.keras.Sequential([ tf.keras.layers.Flatten(input_shape=(28,28)), tf.keras.layers.Dense(128, activation=&apos;relu&apos;), tf.keras.layers.Dense(10, activation=&apos;softmax&apos;)])model.compile(optimizer=&apos;adam&apos;, loss=&apos;sparse_categorical_crossentropy&apos;, metrics=[&apos;accuracy&apos;])model.summary()step_pre_epoch = train_images.shape[0]//32model.fit(ds_train, epochs=5, steps_per_epoch=step_pre_epoch,validation_data=ds_test,validation_steps=test_images.shape[0]//32)# 绘制accuracy图像import matplotlib.pyplot as pltplt.plot(model.history.history[&apos;accuracy&apos;])]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>-机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[米家智能设备通过 HomeAssistant 接入homeKit]]></title>
    <url>%2F2021%2F10%2F10%2Fnas%2F%E7%B1%B3%E5%AE%B6%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87%E9%80%9A%E8%BF%87-HomeAssitant-%E6%8E%A5%E5%85%A5homeKit%2F</url>
    <content type="text"><![CDATA[米家智能设备通过 HomeAssistant 接入homeKit 前言最近刚入手iphone13,得空研究了一下苹果的智能家居。正好家里已经整了一套米家的智能设备,想着用 HomeAssistant(一下简称HA) 实现 苹果生态中接入米家设备。 HomeAssistant 是什么？懒得自己写,网上引用一段 (#^.^#) HomeAssistant是构建智慧空间的神器。是一个成熟完整的基于 Python 的智能家居系统，设备支持度高，支持自动化（Automation)、群组化（Group）、UI 客制化（Theme) 等等高度定制化设置。同样实现设备的 Siri 控制。基于HomeAssistant，可以方便地连接各种外部设备（智能设备、摄像头、邮件、短消息、云服务等，成熟的可连接组件有近千种），手动或按照自己的需求自动化地联动这些外部设备，构建随心所欲的智慧空间。HomeAssistant是开源的，它不属于任何商业公司，用户可以无偿使用。 HomeAssistant的安装智能家居控制需要稳定运行,因此需要运行在树莓派或nas上,正好前段时间入手了威联通的TS-451D,这次就在nas上部署HA系统：打开 Container station 搜索并安装最新版的HA系统镜像 安装时要设置一些东西,网络连接改为和host直连,为了后期homeKit能访问到HA生成的虚拟网关： 增加一个共享文件夹方便后期安装插件调整配置： 镜像文件有一个多G,泡杯茶就好了,|ू･ω･` ) 安装完成后,通过 nas的ip加端口号 8123进行访问初次进行系统需要初始化账号密码,设置完成后进行HA管理页面这里是我已经配置好的界面 HA的配置最好的安装方式是通过安装HACS来管理插件,但是由于国内特殊的网络环境,(⊙o⊙)…,我们还是自己去github上下载插件进行手动安装 https://github.com/ha0y/xiaomi_miot_raw 按照readme下载压缩包并解压到刚刚绑定的共享文件夹中,我这里使用xftp访问nas文件。 在 Container Station 中重启一下 HA服务,添加一下我们刚刚下载的插件 接下来需要绑定一下小米账号,然后就能自由的添加设备,并在总览页面中进行设备的控制了 接入homeKit添加一下homeKit 添加完成后,左下角会出现一个二维码,使用ios的家庭app扫码添加这个虚拟桥接设备 大功告成,搭配你的 homepod 就可以实现对米家设备的自动化控制了 (^o^)/~]]></content>
      <categories>
        <category>nas</category>
      </categories>
      <tags>
        <tag>nas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用frpc进行nas服务访问]]></title>
    <url>%2F2021%2F07%2F26%2Fnas%2F%E4%BD%BF%E7%94%A8frpc%E8%BF%9B%E8%A1%8Cnas%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[使用frpc进行nas服务访问 威联通(QNAP) NAS 穿透指南因为本作者也不用 QNAP ，这篇指南只提供 Docker 部署法。https://doc.natfrp.com/#/app/qnap 使用准备使用准备部分如果看不懂可以类比 DSM 的指南 配置面板打开控制台，勾选 使用安全连接(HTTPS)，并记下下面的 端口号 备用： 在 App Center 中安装 Container Station 以使用 Docker： 在 Container Station 如下图读出 网关ip 备用： 创建隧道使用上一步中记下的参数，如下图所示创建隧道备用： 设置Docker首先我们在 Container Station 中找到并下载 natfrp/frpc 的 latest 标签： 然后设置启动参数： 请注意，此处「命令」栏中输入的是一个启动参数，如何写可以参考 Docker指南 获取连接信息打开 Docker Container 的详情信息就能看到连接信息了，报错也可以在这里看到： 到浏览器试一下： 请注意，因为我们穿透了 HTTPS 访问端口，所以在访问时需要在前面加 https:// 更新软件版本请务必在有备用连接手段时升级，否则可能造成失联 有时候，你会看到我们在 状态频道 中看到新的客户端发布 但是 QNAP 的 Container Station 并不像它在 DSM 的兄弟那样升级便捷 您需要删除掉正在运行的 Container（容器），然后在 镜像文件 菜单中删除已有的 natfrp/frpc，最后跟随 设置Docker 开始重来一遍]]></content>
      <categories>
        <category>nas</category>
      </categories>
      <tags>
        <tag>nas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[softmax多分类]]></title>
    <url>%2F2021%2F05%2F15%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2Fsoftmax%E5%A4%9A%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[softmax多分类实现 softmax多分类回归softmax各个样本分量之和为1。当只有两个类别时,与对数几率回归完全相同。 softmax的交叉熵损失函数在tf.keras中使用categorical_crossentropy和sparse_categorical_crossentropy来计算softmax交叉熵 Fashion MNIST数据集Fashion MNIST的作用是成为经典MNST数据集的简易替换。MNST数据集包含手写数字(0、1、2等)的图像,这些图像的格式与Fashion MNIST使用的服饰图像的格式相同。Fashion MNIST比常规MNST手写数据集更具挑战性。这两个数据集都相对较小,用于验证某个算法能否如期正常运行。它们都是测试和调试代码的良好起点。Fashion MNIST数据集包含70000张灰度图像,涵盖10个类别。我们将使用60000张图像训练网络。并使用10000张图像评估经过学习的网络分类图像的准确率。可以从 TensorFlow直接访问 Fashion MNIST,只需导入和加载数据即可。 链接：提取码：6666 将Fashion MINST 放在C:/用户/你的用户名/.keras/datasets 目录下 学习速率学习速率是一种超参数或对模型的一种手工可配置的设置需要为它指定正确的值。如果学习速率太小,则找到损失函数极小值点时可能需要许多轮迭代;如果太大,则算法可能会“跳过”极小值点并且因周期性的“跳跃”而永远无法找到极小值点。 反向传播算法反向传播算法是一种高效计算数据流图中梯度的技术每一层的导数都是后一层的导数与前一层输出之积,这正是链式法则的奇妙之处,误差反向传播算法利用的正是这一特点。前馈时,从输入开始,逐一计算每个隐含层的输出,直到输出层。然后开始计算导数,并从输出层经过各隐含层逐一反向传播。为了减少计算量,还需对所有已完成计算的元素进行复用这便是反向传播算法名称的由来。 常见的优化函数优化器( optimizer)是编译模型的所需的两个参数之一。你可以先实例化一个优化器对象,然后将它传入model. compile0,或者你可以通过名称来调用优化器。在后一种情况下,将使用优化器的默认参数。 SGD:随机梯度下降优化器随机梯度下降优化器SGD和min-batch是同一个意思,抽取m个小批量(独立同分布)样本,通过计算他们平梯度均值。 RMSprop经验上, RMSProp被证明有效目实用的深度学习网络优化算法RMSProp增加了一个衰减系数来控制历史信息的获取多RMSProp会对学习率进行衰减。 Adam优化器 Adam算法可以看做是修正后的 Momentum+ RMSProp算法. Adam通常被认为对超参数的选择相当鲁棒 学习率建议为0.001 Adam是一种可以替代传统随机梯度下降过程的一阶优化算法,它能基于训练数据迭代地更新神经网络权重。Adam通过计算梯度的一阶矩估计和二阶矩估计而为不同的参数设计独立的自适应性学习率。 如何提高网络的拟合能力一种显然的想法是增大网络容量: 增加隐藏层深度 增加隐藏神经元个数 这两种方法哪种更好呢? 单纯的增加神经元个数对于网络性能的提高并不明显,而增加层会大大提高网络的拟合能力这也是为什么现在深度学习的层越来越深的原因。 注意 单层的神经元个数,不能太小,太小的话,会造成信息瓶颈,使得模型欠拟合。 dropout防止过拟合为什么说 Dropout可以解决过拟合? 取平均的作用:我们用相同的训练数据去训陈5个不同的神经网络,一般会得到5个不同的结果,此时我们可以采用“5个结果取均值”或者“多数取胜的投票策略″去决定最终结果。 减少神经元之间复杂的共适应关系:因为 dropout程序导致两个神经元不一定每次都在一个 dropout网络中出现。这样权值的更新不再依赖于有固定关系的隐含节点的共同作用,阻止了某些特征仅仅在其它特定特征下才有效果的情况。 构建网络的总原则 增大网络容量直到过拟合 采取措施抑制过拟合 (dropout、正则化、图像增强、加大数据集、交叉验证) 继续增大网络容量直到过拟合 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import tensorflow as tfimport pandas as pd import matplotlib.pyplot as pltimport numpy as np# 在jupyter notebook中使用,使结果直接输出在控制台中 # %matplotlib inline(train_image,train_label),(test_image,test_label) = tf.keras.datasets.fashion_mnist.load_data()# 数据归一化train_image = train_image/255test_image = test_image/255model = tf.keras.Sequential()# 数据扁平化model.add(tf.keras.layers.Flatten(input_shape=(28,28)))model.add(tf.keras.layers.Dense(32, activation='relu'))model.add(tf.keras.layers.Dense(10,activation='softmax'))model.compile( optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['acc'])history = model.fit(train_image,train_label,epochs=30,validation_data=(test_image,test_label))# 绘制loss函数折线图plt.plot(history.epoch,history.history.get('loss'),label='loss')plt.plot(history.epoch,history.history.get('val_loss'),label='val_loss')plt.legend()# 绘制acc折线图plt.plot(history.epoch,history.history.get('acc'),label='acc')plt.plot(history.epoch,history.history.get('val_acc'),label='val_acc')plt.legend()# 转换独热编码train_label_onehot = tf.keras.utils.to_categorical(train_label)test_label_onehot = tf.keras.utils.to_categorical(test_label)model = tf.keras.Sequential()# 数据扁平化model.add(tf.keras.layers.Flatten(input_shape=(28,28)))model.add(tf.keras.layers.Dense(128, activation='relu'))model.add(tf.keras.layers.Dense(10,activation='softmax'))model.compile( optimizer='adam', loss='categorical_crossentropy', metrics=['acc'])model.fit(train_image,train_label_onehot,epochs=5)predict = model.predict(test_image)# 预测结果 9np.argmax(predict[0])# label对应结果也是9test_label[0]]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>-机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tf.keras概述]]></title>
    <url>%2F2021%2F04%2F24%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2Ftf.keras%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[tf.keras概述 使用tf.keras实现一个简单的线性回归建立一个受教育年限和收入的线性预测模型123456789101112131415161718192021222324252627import tensorflow as tfimport pandas as pd import matplotlib.pyplot as plt# 在jupyter notebook中使用,使结果直接输出在控制台中 %matplotlib inlineprint(tf.__version__)# 读取数据data = pd.read_csv('Income1.csv')data# 绘制散点图plt.scatter(data.Education,data.Income)# 定义维度x = data.Education y = data.Income# 建立线性模型model = tf.keras.Sequential()model.add(tf.keras.layers.Dense(1,input_shape=(1,)))# 打印模型信息model.summary()# 定义优化器和损失函数model.compile( optimizer='adam', loss='mse')history = model.fit(x,y,epochs=5000)# 使用模型预测model.predict(pd.Series([8])) 梯度下降算法梯度下降算法是一种致力于找到函数极值点的算法。 梯度的输出是一个由若干偏导数构成的向量,他的每个分量对应于函数对输入向量的相应分量的偏导。 梯度的输出向量表明了在每个位置损失函数增长的最快的方向,可将它视为表示了在函数的每个位置向哪个方向移动函数值可以增长。 多层感知器 单层神经元的缺陷神经元要求数据必须是线性可分的异或问题无法找到一条直线分割两个类。 多层神经元生物的神经元一层一层连接起来,当神经信号达到某一个条件,这个神经元就会激活,然后继续传递信息下去。为了继续使用神经网络解决这种不具备线性可分性的问题,采取在神经网络的输入端和输出端之间插入更多的神经元 relu激活函数 sigmoid激活函数 tanh激活函数 使用tf.keras实现一个简单的逻辑回归1234567891011121314151617181920212223import tensorflow as tfimport pandas as pd import matplotlib.pyplot as plt# 在jupyter notebook中使用,使结果直接输出在控制台中 %matplotlib inlinedata = pd.read_csv('credit-a.csv',header=None)# 定义维度x = data.iloc[:, :-1]y = data.iloc[:, -1].replace(-1,0)x# 创建模型model = tf.keras.Sequential()model.add(tf.keras.layers.Dense(100, input_shape=(15,),activation='relu'))model.add(tf.keras.layers.Dense(100, activation='relu'))model.add(tf.keras.layers.Dense(1, activation='sigmoid'))model.compile( optimizer='adam', loss='binary_crossentropy', metrics=['acc'])history = model.fit(x,y,epochs=1000)model.predict(data.iloc[:20, :-1])plt.plot(history.epoch,history.history.get('acc')) 逻辑回归损失函数平方差(mse)所适用的是数据与损失为同一数量级的情形对于分类问题,我们最好的使用交叉熵损失函数会更有效交叉熵会输出一个更大的“损失”。 交叉熵损失函数交叉熵刻画的是实际输岀(概率)与期望输岀(概率)的距离,也就是交叉熵的值越小,两个概率分布就越接近。在Keras中,使用binary_crossentropy来计算二元交叉熵]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>-机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow2.0]]></title>
    <url>%2F2021%2F03%2F11%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2Ftensorflow2.0%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Tensorflow2.0介绍与安装 Tensorflow2.0 特点在研究方面：为研究提供强大的实验工具。 Tf.keras: 允许创建复杂的拓扑，包括使用残差值、自定义多输入/输出模型以及强制编写的正向传递。轻松创建自定义训练循环。低级Tensorflow API始终可用，并与更高级别的抽象一起工作，以实现完全可定制的逻辑。 在部署方面：在任意平台上实现稳健的生产环境模型部署。 不论是在服务器、边缘设备还是网页上，也不论你使用的是什么语言或平台，Tensorflow总能让你轻易训练和部署模型。 Tensorflow2.0 安装miniconda Conda是一个包管理器;Anaconda是一个发行包conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换Anaconda是一个打包的集合器皿，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。也可以理解：conda是包的管理，可以安装包（conda install samtools），删除环境，查找等用法。其实还有Miniconda，顾名思义，它只包含最基本的内容——python与conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda是一种选择 使用miniconda安装tensorflow2.0打开miniconda命令窗口 输入1pip install tensorflow-cpu==2.3.0 -i https://pypi.douban.com/simple/ 安装完成后 依次输入123pythonimport tensorflow as tfprint(tf.__version__) 显示版本号则安装成功]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-kms激活]]></title>
    <url>%2F2020%2F02%2F18%2Fwindows%2Fwindows-kms%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[windows-kms激活 激活步骤 以管理员身份打开powershell 输入 slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX 安装激活秘钥 输入 slmgr /skms zh.us.to设置kms服务器 最后执行命令 slmgr /ato注册完成 kms激活windows以180天为一个周期，之后需要再次执行此操作重复激活 秘钥Windows 10 Professional(专业版)：W269N-WFGWX-YVC9B-4J6C9-T83GX Windows 10 Professional N(专业版N)：MH37W-N47XK-V7XM9-C7227-GCQG9 Windows 10 Enterprise(企业版)：NPPR9-FWDCX-D2C8J-H872K-2YT43 Windows 10 Enterprise N(企业版N)：DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4 Windows 10 Education(教育版)：NW6C2-QMPVW-D7KKK-3GKT6-VCFB2 Windows 10 Education N(教育版N)：2WH4N-8QGBV-H22JP-CT43Q-MDWWJ 最近被各种事情扰乱了思绪，该调整心态重新出发了，武汉加油，祝未来可期]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow开发环境搭建]]></title>
    <url>%2F2019%2F10%2F01%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2Ftensorflow%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[tensorflow开发环境搭建 安装 python需要安装64位版本python v3.7.4 64 bit解压安装傻瓜式安装安装完成后windows需要配置环境变量 安装pip12$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py # 下载安装脚本$ python get-pip.py # 运行安装脚本 安装虚拟环境 virtualenv1pip install virtualenv #使用pip安装 virtualenv 创建虚拟环境虚拟环境的用处 与主机环境隔离。 每个虚拟环境都独立安装python模块,可以通过切换虚拟环境使用不同版本的python模块。 语法12345virtualenv --system-site-packages -p python ./venv #创建名为venv的虚拟环境cd venv #进入虚拟环境目录cd Scripts #进入脚本目录activate #执行虚拟环境激活命令deactivate #退出虚拟环境 激活时会独立于主机的python独立安装一些初始模块 pip、wheel,使用1pip list 查看安装的模块及版本 安装Tensorflow在激活的虚拟环境中使用1pip install tensorflow 安装tensorflow的cpu版本,想要下载更多的版本可以使用1pip search Tensorflow 查询适合当前python版本的tensorflow版本这里是官网的对tensorflow不同版本的解释 tensorflow - 仅支持 CPU 的最新稳定版（建议新手使用） tensorflow-gpu - 支持 GPU 的最新稳定版（适用于 Ubuntu 和 Windows） tf-nightly - 仅支持 CPU 的预览每夜版（不稳定） tf-nightly-gpu - 支持 GPU 的预览每夜版（不稳定，适用于 Ubuntu 和 Windows） tensorflow==2.0.0-rc1 - 仅支持 CPU 的预览 TensorFlow 2.0 测试版（不稳定） tensorflow-gpu==2.0.0-rc1 - 支持 GPU 的预览 TensorFlow 2.0 测试版（不稳定，适用于 Ubuntu 和 Windows） 测试1python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot; 如果成功执行这行代码,则安装成功 hello world使用内置的手写数字训练集进行模型的训练123456789101112131415161718192021import tensorflow as tf # 导入tensorflow模块mnist = tf.keras.datasets.mnist # 获取预置的mnist手写数据集(x_train, y_train),(x_test, y_test) = mnist.load_data() # 获取预先划分好的训练集,测试集x_train, x_test = x_train / 255.0, x_test / 255.0 # 对图片像素进行规范化 从[0,255]规整为[0,1]# 创建一个训练模型model = tf.keras.models.Sequential([ tf.keras.layers.Flatten(input_shape=(28, 28)), # 输入层规定输入图片尺寸为28px × 28px tf.keras.layers.Dense(512, activation=tf.nn.relu),# 第一层神经元个数为512 使用relu作为激活函数 tf.keras.layers.Dense(1024, activation=tf.nn.relu),# 第二层神经元个数为1024 同样使用relu作为激活函数 tf.keras.layers.Dropout(0.2), # 随机失活层防止过拟合 tf.keras.layers.Dense(10, activation=tf.nn.softmax) # 输出层 使用softmax激活函数进行分类])# 使用adam为优化器,sparse_categorical_crossentropy为loss计算函数model.compile(optimizer=&apos;adam&apos;, loss=&apos;sparse_categorical_crossentropy&apos;, metrics=[&apos;accuracy&apos;])# 开始训练,进行100层迭代model.fit(x_train, y_train, epochs=100)# 使用测试数据集进行模型准确度评估model.evaluate(x_test, y_test) 训练集的样本个数为60000,测试用样本个数为10000,训练进行时会有如下输出:12345678910111213141516171819202122232425262728Epoch 87/10060000/60000 [==============================] - 10s 174us/sample - loss: 0.0102 - acc: 0.9987Epoch 88/10060000/60000 [==============================] - 11s 175us/sample - loss: 0.0117 - acc: 0.9987Epoch 89/10060000/60000 [==============================] - 11s 180us/sample - loss: 0.0192 - acc: 0.9981Epoch 90/10060000/60000 [==============================] - 11s 178us/sample - loss: 0.0128 - acc: 0.9987Epoch 91/10060000/60000 [==============================] - 10s 174us/sample - loss: 0.0156 - acc: 0.9985Epoch 92/10060000/60000 [==============================] - 11s 180us/sample - loss: 0.0128 - acc: 0.9988Epoch 93/10060000/60000 [==============================] - 10s 172us/sample - loss: 0.0212 - acc: 0.9984Epoch 94/10060000/60000 [==============================] - 11s 185us/sample - loss: 0.0137 - acc: 0.9986Epoch 95/10060000/60000 [==============================] - 11s 177us/sample - loss: 0.0161 - acc: 0.9987Epoch 96/10060000/60000 [==============================] - 11s 179us/sample - loss: 0.0113 - acc: 0.9989Epoch 97/10060000/60000 [==============================] - 11s 180us/sample - loss: 0.0181 - acc: 0.9986Epoch 98/10060000/60000 [==============================] - 10s 169us/sample - loss: 0.0148 - acc: 0.9986Epoch 99/10060000/60000 [==============================] - 11s 177us/sample - loss: 0.0140 - acc: 0.9989Epoch 100/10060000/60000 [==============================] - 11s 179us/sample - loss: 0.0207 - acc: 0.9984 loss值和acc一般成反比,可以看出每一次迭代后模型对自己的评估。然而这样的评估不一定准确,需要使用不参与训练的测试数据集进行评估。110000/10000 [==============================] - 1s 53us/sample - loss: 0.6206 - acc: 0.9807 10000个测试样本的准确率为 98%,可以证明这个模型可以很好的区分手写数字了。]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六周工作笔记]]></title>
    <url>%2F2019%2F08%2F16%2F%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%2F%E7%AC%AC%E5%85%AD%E5%91%A8%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第六周工作笔记 css flex布局元素垂直居中html123&lt;div class="flex-box"&gt; &lt;span class="inner"&gt;&lt;/span&gt;&lt;/div&gt; css123456789101112.flex-box&#123; display:flex; justify-content: center; /* 水平居中 */ align-items: center; /* 垂直居中 */ flex-direction: column; /* 纵向排列 */&#125;.inner&#123; width: 200px; height: 200px; border: 1px solid red;&#125; css 禁止选中事件1234567-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; Unsatisfied dependency expressed through field错误原因：业务实现类没有@Service注解 js冒泡js中的click事件在触发时会从点击的dom节点开始向上扩散，触发所有能触发的事件 阻止冒泡1event.stopPropagation();//阻止事件冒泡 flex布局html:12345&lt;div class = "test"&gt; &lt;div class = "item1"&gt;1&lt;/div&gt; &lt;div class = "item2"&gt;2&lt;/div&gt; &lt;div class = "item3"&gt;3&lt;/div&gt;&lt;/div&gt; css:12345678910111213141516171819202122232425.test&#123; //使用flex布局 display: flex; //水平居中 justify-content: center; //垂直居中 align-items: center; //纵向布局 flex-flow: column;&#125;.item1&#123; //所占权重大小 flex: 1; background: red;&#125;.item2&#123; //所占权重大小 flex: 2; background: blue;&#125;.item3&#123; //所占权重大小 flex: 3; background: green;&#125; ![渐变][/img/post/7-1.png] jquery内置方法注意事项jquery所有的方法，如append()、hide()、show()等都需要使用$().method()的方式调用，如果使用js变量会失效 拖拽缩放插件 l_zoom l_drag应项目需求在一个原有插件的基础上实现了一个拖拽缩放插件，支持： 上下左右、四个角的自由拖拽，且可以自定义最小尺寸。 可以传入缩放大小以适应 transform：scale 造成的元素变幻。 可以通过方法进行拖拽功能的禁用与赋予。 项目地址]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四五周工作笔记]]></title>
    <url>%2F2019%2F08%2F10%2F%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%2F%E7%AC%AC%E5%9B%9B%E4%BA%94%E5%91%A8%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第四五周工作笔记 动态修改网页title1$("title").html("修改"); 需要保证在head中已经加入了title标签 js获取url参数12345678910function getQueryVariable(variable)&#123; var query = window.location.search.substring(1); var vars = query.split("&amp;"); for (var i=0;i&lt;vars.length;i++) &#123; var pair = vars[i].split("="); if(pair[0] == variable)&#123;return pair[1];&#125; &#125; return(false); &#125; jquery动态添加的dom元素无法绑定事件问题写法123$('.className').click(function()&#123; //TODO&#125;); 对后来添加的dom元素依旧有效的事件绑定123$('body').on('click','.className',function()&#123; //TODO&#125;); 汉字乱码前端从地址栏中获得的中文参数会被转换成十六进制编码 JS解决方案1decodeURI(String string) js replace全局替换定值替换1str.replace(/string/g,"要替换成的字符"); 变量替换123var key = "key";var key = "/"+key+"/g";str.replace(eval(key),"要替换成的字符"); java 取消科学计数法1234NumberFormat format = NumberFormat.getInstance(); // 取消科学计数法format.setGroupingUsed(false);format.format("要处理的数字"); solr基本使用基本查询12345678910111213141516//定义查询条件SolrQuery solr = new SolrQuery();solr.setQuery("sql");//从什么地方开始solr.setStart();//查询多少条solr.setRows();//查询HttpSolrClient hs= new HttpSolrClient("http...");try&#123; QueryResponse qr = hs.query();&#125;catch&#123;&#125;//获取结果solrDocumentList solrlist = qr.getResult(); FaceT分组12345678910111213//定义查询条件SolrQuery solr = new SolrQuery();solr.setQuery("sql");//从什么地方开始solr.setStart();//查询多少条solr.setRows();//开启分组solr.setFacet(true);//设置要分组的字段solr.addFacetField("field");//获取分组结果List&lt;FacetField&gt; facetFields = queryResponse.getFacetFields(); FaceT多维度分组12345678910111213141516171819202122232425//定义查询条件SolrQuery solr = new SolrQuery();solr.setQuery("sql");//从什么地方开始solr.setStart();//查询多少条solr.setRows();//开启分组solr.setFacet(true);//添加分组字段solr.add("facet.pivot", "String1,String2");QueryResponse response = new QueryResponse();response = new HttpSolrClient("http:...").query(solr);// 获取分组结果集合NamedList&lt;List&lt;PivotField&gt;&gt; namedList = queryResponse.getFacetPivot();//获取详细数据var List&lt;PivotField&gt; list = namedList.getVal(0);//遍历结果集合for(PivotField field : list)&#123; //获取值 System.out.println("value:"+field.getValue()); //获取计数 System.out.println("count:"+field.count()); //每对 PivotField 对象进行一次遍历 就能拿到更深一层的分类&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三周工作笔记]]></title>
    <url>%2F2019%2F07%2F27%2F%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%2F%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第三周工作笔记 重写提交方法后阻止表单自提交重写表单中的submit按钮123456789&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; onclick=&quot;do()&quot;/&gt;&lt;/form&gt;&lt;script&gt; function do()&#123; &#125;&lt;/script&gt; 阻止表单自提交(法一)123456789&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; onclick=&quot;return do()&quot;/&gt;&lt;/form&gt;&lt;script&gt; function do()&#123; return false; &#125;&lt;/script&gt; 阻止表单自提交(法二)123456789&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; onclick=&quot;do(event)&quot;/&gt;&lt;/form&gt;&lt;script&gt; function do(event)&#123; event.preventDefault(); &#125;&lt;/script&gt; java构建json数据目标json格式1234567[&#123; name: "", children: [&#123; name: "", children: [&#123;&#125;] &#125;]&#125;] 具体实现在相应的实体类中定义实体类数组children1234567private ArrayList&lt;CityInfo&gt; children;public ArrayList&lt;CityInfo&gt; getChildren()&#123; return this.children;&#125;public void setChildren(ArrayList&lt;CityInfo&gt; cInfos)&#123; this.children = cInfos;&#125; 使用mybatis-plus的条件查询方法获得实体类list12345List&lt;CityInfo&gt; city = new ArrayList&lt;CityInfo&gt;(); //查询城市信息 QueryWrapper&lt;CityInfo&gt; qWrapper = new QueryWrapper&lt;&gt;(); qWrapper.select("dqid,dqmc,dqjb,sjdqid,children"); city = cityDao.selectList(qWrapper); 目标json格式是三维的，并且需要将子节点放到对应得父节点的children中定义三个实体类list并从底层开始拼接json数据1234567891011121314151617181920212223242526272829303132//用来存储三级城市信息的list List&lt;CityInfo&gt;arrTop = new ArrayList&lt;CityInfo&gt;(); List&lt;CityInfo&gt;arrSec = new ArrayList&lt;CityInfo&gt;(); List&lt;CityInfo&gt;arrThi = new ArrayList&lt;CityInfo&gt;(); for(CityInfo cInfo:city )&#123; if(cInfo.getDqjb().equals("3"))&#123; arrThi.add(cInfo); &#125; if(cInfo.getDqjb().equals("2"))&#123; arrSec.add(cInfo); &#125; if(cInfo.getDqjb().equals("1"))&#123; arrTop.add(cInfo); &#125; &#125; //组装二级json for(int i=0;i&lt;arrSec.size();i++)&#123; for(int j=0;j&lt;arrThi.size();j++)&#123; if(arrThi.get(j).getSjdqid().equals(arrSec.get(i).getDqid()))&#123; arrSec.get(i).putChildren(arrThi.get(j)); &#125; &#125; &#125; //组装一级json for(int i=0;i&lt;arrTop.size();i++)&#123; for(int j=0;j&lt;arrSec.size();j++)&#123; if(arrSec.get(j).getSjdqid().equals(arrTop.get(i).getDqid()))&#123; arrTop.get(i).putChildren(arrSec.get(j)); &#125; &#125; &#125; 将最后的实体类list通过fastJson的JSON.toJSONString转换成json格式1returnJson = JSON.toJSONString(arrTop); zTree插件的使用配置文件12345678910111213141516171819202122232425262728293031 var setting_city = &#123; async:&#123; enable:true, type: "get", dataFilter: filter, url:"&lt;%=path%&gt;/admin/cityData" &#125;, view: &#123; selectedMulti: false, expandSpeed: "normal" &#125;, check: &#123; enable: true &#125;, data: &#123; key:&#123; name: "dqmc" &#125;, simpleData: &#123; //根据json数据变化 enable: true, idKey: "dqid", pIdKey: "sjdqid" &#125; &#125;, callback:&#123; beforeCheck:checkYZ, onCheck:onCheck, onAsyncSuccess: zTreeOnAsyncSuccess &#125;&#125;; 在html中定义一个ul标签1&lt;ul id="cityTree" class="ztree cityTree"&gt;&lt;/ul&gt; 从服务器端返回的数据不能直接解析，需要先通过async配置的filter转换成json对象12345//数据预处理function filter(treeId, parentNode, responseData)&#123; var data = JSON.parse(responseData); return data;&#125; 使用配置文件进行初始化1$.fn.zTree.init($("#cityTree"),setting_city,null); 效果图]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二周工作笔记]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%2F%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第二周工作笔记 mybatis-plus的安装与配置随着系统开发的深入，数据处理层维护的sql语句越来越多，且大部分时间都在重复相同的操作，因此使用mybatis-plus取代mybatis进行dao层的开发与维护。,mybatis-plus基于mybatis进行扩展，因此不需要改动之前的sql语句，可以在新的持久层框架下进行sql的操作。 mybatis-plus的安装在pom.xml中添加相关的依赖12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.1.2&lt;/version&gt;&lt;/dependency&gt; 同时还要取消掉原来 mybatis和mybatis-spring的依赖防止冲突。项目框架中还使用了mybatis-ehcache，保险起见也取消其依赖。同时在 spring-datasource.xml取消其bean设置。 mybatis-plus的配置打开spring-mybatis进行以下配置1234567891011121314151617&lt;!-- SqlSessionFactory Config --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/project/qcc/mapper/*Mapper.xml&quot;/&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.project.qcc.entity&quot; /&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean class=&quot;com.baomidou.mybatisplus.extension.plugins.PerformanceInterceptor&quot;&gt;&lt;/bean&gt; &lt;bean class=&quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor&quot;&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- MyBatis Mapper Scan Config --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.project.qcc.dao&quot;/&gt; &lt;/bean&gt; 至此配置完成。 mybatis-plus的使用相关类的继承在实体类使用注解声明实体类对应的表名1@Tablename(&quot;name&quot;) 在实体类使用注解声明表的主键1@TableId 使dao层接口继承 mybatis-plus的 baseMapper1public interface UserInfoMapper extends BaseMapper&lt;UserInfo&gt;&#123;&#125; 使用baseMapper封装好的CRUD方法进行dao层操作api使用手册 使service层接口继承 mybatis-plus的 IService1public interface UserService extends IService&lt;UserInfo&gt;&#123;&#125; 使serviceImpl继承 mybatis-plus的 ServiceImpl1public class UserServiceImpl extends ServiceImpl&lt;UserInfoMapper, UserInfo&gt; implements UserService &#123;&#125; 使用IService封装好的CRUD方法进行Service层操作api使用手册 在Controller中编写测试类测试类123456789101112131415161718192021222324252627@RequestMapping(value=&quot;/test&quot;) public Object v_test()&#123; //查询记录总数 int count = userDao.selectCount(null); System.out.println(count); //查询全部记录 List&lt;UserInfo&gt; userInfo = userDao.selectList(null); userInfo.forEach(System.out::println); //使用id更新字段 UserInfo userInfo2 = userDao.selectById(&quot;10005&quot;); System.out.println(userInfo2.toString()); userInfo2.setEmail(&quot;1036192040@qq.com&quot;); //使用id更新email int res = userDao.updateById(userInfo2); System.out.println(&quot;成功结果数：&quot;+res); //使用service层封装方法进行 根据id进行批量更新 UserInfo userInfo1 = userService.getById(&quot;10001&quot;); UserInfo userInfo21 = userService.getById(&quot;10003&quot;); List&lt;UserInfo&gt; list = new ArrayList&lt;UserInfo&gt;(); userInfo1.setEmail(&quot;test1&quot;); userInfo21.setEmail(&quot;test2&quot;); list.add(userInfo1); list.add(userInfo21); boolean isSuccess = userService.updateBatchById(list); System.out.println(&quot;更新:&quot;+isSuccess); return true; &#125; 输出结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Time：17 ms - ID：com.project.qcc.dao.UserInfoMapper.selectCountExecute SQL：com.mchange.v2.c3p0.impl.NewProxyPreparedStatement@72db4ef726 Time：15 ms - ID：com.project.qcc.dao.UserInfoMapper.selectListExecute SQL：com.mchange.v2.c3p0.impl.NewProxyPreparedStatement@15e1681aUserInfo [userid=10000, loginname=admin, password=3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d, cjsj=2019-07-15 08:54:59.0, xgsj=2019-07-15 08:54:59.0, username=admin, roleName=, status=1, manage=3]UserInfo [userid=10001, loginname=admin11, password=3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d, cjsj=2019-07-15 09:45:54.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10002, loginname=zhaochong, password=fa376e383626491fb6f3b6b5c06b1c208bba702b, cjsj=2019-07-15 08:55:07.0, xgsj=2019-07-15 10:59:38.0, username=无, roleName=, status=1, manage=3]UserInfo [userid=10003, loginname=admin111, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-15 09:43:08.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10004, loginname=wodemaya, password=3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d, cjsj=2019-07-15 09:43:08.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10005, loginname=admin1111, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-15 09:43:08.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10006, loginname=admin11111, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-15 09:43:08.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10007, loginname=zhaochong1, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-15 09:43:08.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10008, loginname=sadasd, password=3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d, cjsj=2019-07-15 09:43:08.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10009, loginname=zhaochong122, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-15 09:43:08.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10010, loginname=zhaochong122, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-15 09:43:08.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10011, loginname=123123, password=7110eda4d09e062aa5e4a390b0a572ac0d2c0220, cjsj=2019-07-15 09:43:08.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10012, loginname=adminw, password=3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d, cjsj=2019-07-15 09:46:05.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10013, loginname=admin2, password=3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d, cjsj=2019-07-15 09:22:04.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10014, loginname=sssss, password=3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d, cjsj=2019-07-15 09:22:03.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10015, loginname=admin23, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-15 08:47:51.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10016, loginname=12312311, password=78f8bb4c43c7c3e4e5883e8e9b18518c89d965ff, cjsj=2019-07-15 09:22:01.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10017, loginname=zhaochong11, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-15 09:21:58.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10018, loginname=xxxxx, password=7b21848ac9af35be0ddb2d6b9fc3851934db8420, cjsj=2019-07-15 09:21:54.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10019, loginname=as11111, password=7b21848ac9af35be0ddb2d6b9fc3851934db8420, cjsj=2019-07-15 09:21:56.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10020, loginname=sssssssss, password=7b21848ac9af35be0ddb2d6b9fc3851934db8420, cjsj=2019-07-15 09:21:52.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10022, loginname=zhaochong333, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-23 09:48:35.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10024, loginname=123123ss, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-15 10:03:45.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10025, loginname=test, password=3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d, cjsj=2019-07-15 10:58:29.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10026, loginname=zhaochong123, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-15 15:07:03.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1]UserInfo [userid=10027, loginname=adminsdsd, password=7b21848ac9af35be0ddb2d6b9fc3851934db8420, cjsj=2019-07-15 18:00:19.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1] Time：5 ms - ID：com.project.qcc.dao.UserInfoMapper.selectByIdExecute SQL：com.mchange.v2.c3p0.impl.NewProxyPreparedStatement@81c43ddUserInfo [userid=10005, loginname=admin1111, password=011c945f30ce2cbafc452f39840f025693339c42, cjsj=2019-07-15 09:43:08.0, xgsj=2019-07-16 09:15:16.0, username=无, roleName=, status=1, manage=1] Time：7 ms - ID：com.project.qcc.dao.UserInfoMapper.updateByIdExecute SQL：com.mchange.v2.c3p0.impl.NewProxyPreparedStatement@42aba9c6成功结果数：1 Time：3 ms - ID：com.project.qcc.dao.UserInfoMapper.selectByIdExecute SQL：com.mchange.v2.c3p0.impl.NewProxyPreparedStatement@6cafa6fd Time：4 ms - ID：com.project.qcc.dao.UserInfoMapper.selectByIdExecute SQL：com.mchange.v2.c3p0.impl.NewProxyPreparedStatement@739e71ec Time：0 ms - ID：com.project.qcc.dao.UserInfoMapper.updateByIdExecute SQL：com.mchange.v2.c3p0.impl.NewProxyPreparedStatement@53c58db Time：0 ms - ID：com.project.qcc.dao.UserInfoMapper.updateByIdExecute SQL：com.mchange.v2.c3p0.impl.NewProxyPreparedStatement@53c58db更新:true ajax传递数组前端需要加入1jQuery.ajaxSettings.traditional = true; 后端在传入参数中设置与ajax上传的同名参数1234$.post(&quot;url&quot;,&#123;name:name&#125;,function(data)&#123;&#125;)public Object test(String []name)&#123;&#125; 前端解析json需要后台返回 JsonObject 在前端使用JSON.parse解析 不使用submit按钮进行jqery验证1$(&quot;#formid&quot;).valid(); mybatis-plus使用注意mybatis-plus中的baseMapper接口 在有两个以上接口类继承它时 编译器会报 required a single bean, but 2 were found 的错误。研究别人项目的配置文件时发现几乎所有的spring版本都在4.0以上,故进行了spring的升级,可以正常运行。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一周工作笔记]]></title>
    <url>%2F2019%2F07%2F12%2F%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%2F%E7%AC%AC%E4%B8%80%E5%91%A8%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一周工作笔记 html转jsp先在html的顶部加入12&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 声明完成之后将.html的后缀改为.jsp,否则直接更改会出现中文乱码，引入标签库，可以使用c标签进行前端数据的渲染 SSM框架前端url访问在UTF-8声明后加上1234&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt; 与thinkphp的模块/控制器/方法 的访问模式不同SSM通过控制器拦截访问的url并在控制器中确定要渲染的jsp页面因此要指定jsp页面中的url需要先获得当前项目的根目录，否则会出现在开发环境可以正常访问，但在部署时会访问不了的情况。这种获取方式与TP框架在配置文件中定义地址变量的方式 如出一辙path指向/项目 是相对路径basePath指向 域名/端口号/项目 是绝对路径jsp页面中所有的url都需要通过path或basePath来访问 jquery的ajax写法1234567891011$.post(&quot;url&quot;,&#123;param1:value,param2:value&#125;,function(data)&#123; //将得到的字符串转换成json var obj = eval(&quot;(&quot;+data+&quot;)&quot;); //使用返回的success属性判断请求是否成功 if(obj.success)&#123; //TODO &#125;else&#123; //TODO &#125; &#125;); 监听触发按键事件12345document.onkeydown = function(e)&#123; var e = event || window.event; if(e&amp;&amp;e.keycode == 13) //TODO&#125; 如果不使用submit按钮而使用ajax提交form表单的数据，html就不会自动的处理回车事件 jquery validate 插件的使用标准写法:123456789101112131415161718192021222324252627282930313233343536$(&quot;#formId&quot;).validate(&#123; rules:&#123; //需要被验证的控件拥有name属性 name1:&#123; required: true, remote:&#123; url: &quot;&quot;, type: &quot;post&quot;, dataType: &quot;json&quot;, //data的回调函数必须这么写 data:&#123; name1:function(data)&#123; return $(#name1).val(); &#125; &#125; &#125; &#125;, name2:&#123; minlength: 2 &#125;, name3:&#123; maxlength: 3, equalTo: &quot;#name2&quot; &#125; &#125;, messages:&#123; ...... &#125;&#125;)//用户名称验证器$.validator.addMethod(&quot;checkName&quot;,function(value,element,params)&#123; var checkName = /^\w&#123;3,12&#125;$/g; return this.optional(element)||(checkName.test(value));&#125;,&quot;*只允许3-12位英文字母、数字或者下画线！&quot;); 要使用这个验证插件需要保证表单中有submit按钮，否则不会触发验证功能在处理remote的控制器中需要加上 @Responsebody,表示返回数据 mybaits的插入写法123456&lt;!-- 插入用户注册信息 --&gt; &lt;insert id=&quot;InsertUserInfo&quot; parameterType=&quot;java.lang.String&quot;&gt; insert into T_USER (LOGINNAME,PASSWORD) values (#&#123;param1,jdbcType=VARCHAR&#125;,#&#123;param2,jdbcType=VARCHAR&#125;) &lt;/insert&gt; #{param}这种占位符写法表示mybaits会自动进行sql的防注入在插入多条字段时需要指定插入的位置及字段类型 控制html页面元素不能被选中123document.body.onselectstart = function()&#123; return false; &#125; jsp引入模板文件1&lt;%@ taglib uri=&quot;http://java.sun.com/jstl/core_rt&quot; prefix=&quot;c&quot;%&gt; 在要被引入的jsp页面加入此声明之后才可以使用 命令 session拦截类报错错误信息:1Error configuring application listener of class 解决办法:在类中添加一个无参的构造函数 dataTable插件使用注意保证table的布局如下:1234&lt;table id = &quot;tablename&quot;&gt; &lt;thead&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt; 在这个插件中只有tbody标签中的内容会被识别为table的内容，其封装的一些功能也需要tbody中有内容才能正常使用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js立即执行函数的使用场景]]></title>
    <url>%2F2019%2F06%2F16%2F%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%2FJS%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Js立即执行函数的使用场景 立即执行函数的使用1234(function()&#123;&#125;)(); 立即执行函数在定义完后即执行，执行完之后就销毁自身，因此在立即执行函数中声明的变量不会污染全局变量。 使用场景123456for(var i=1;i&lt;10;i++)&#123; setTimeout( function()&#123; console.log(i); &#125;,100)&#125; 按正常逻辑来说控制台应该会打印1到9九个数字，但是由于setTimeout是异步方法，只会在同步进程完成后再执行，因此输出的结果为9个10。 12345678for(var i=1;i&lt;10;i++)&#123; (function()&#123; setTimeout( function()&#123; console.log(i); &#125;,100) &#125;)();&#125; 使用立即执行函数包含异步方法，使得每一次循环后都会执行一次延时方法，这时控制台就会正常打印10个数字。]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache部署TP项目pathInfo的设置]]></title>
    <url>%2F2019%2F05%2F26%2FLinux%2FApache%E9%83%A8%E7%BD%B2TP%E9%A1%B9%E7%9B%AEpathInfo%E7%9A%84%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Apache安装完成后，默认没有使用pathInfo模式，tp框架的项目在部署后会报404错误 Apache配置加载rewrite模块打开Apache配置文件1vim /etc/httpd/conf/httpd.conf 在任意位置添加下面这行代码1LoadModule rewrite_module modules/mod_rewrite.so 修改目录配置找到下面的代码并修改AllowOverride为 All，添加 AcceptPathInfo On 123456&lt;Directory &quot;/var/www/html&quot;&gt; Options Indexes FollowSymLinks AllowOverride All AcceptPathInfo On Require all granted&lt;/Directory&gt; 重启httpd服务 测试]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建lamp环境]]></title>
    <url>%2F2019%2F05%2F26%2FLinux%2F%E6%90%AD%E5%BB%BAlamp%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[使用yum安装搭建lamp环境 安装环境操作系统：CentOS7硬件配置：1 核 2 GB 1 Mbps 使用工具Xshell: 连接服务器键入命令WinSCP: 上传文件 yum安装Apache1yum -y install httpd 安装成功以后使用以下命令启动httpd 1systemctl start httpd 启动成功以后使用ip地址访问会出现下图所示页面 yum安装PHP1yum -y install php 安装成功以后使用以下命令重新启动httpd 1systemctl restart httpd 在/var/www/html目录下新建一个php文件测试 phpinfo()函数 使用 ip地址/info.php访问出现如下信息 yum安装MySQLCentOS7中默认使用MariaDB数据库因此要安装MySQL需要从官网获取yum安装的镜像包1wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 解压镜像包 1rpm -ivh mysql-community-release-el7-5.noarch.rpm 使用yum安装解压后的yum镜像源 1yum install mysql-server 安装时会提示是否要下载依赖包，要选择是 123Total download size: 83 MInstalled size: 356 MIs this ok [y/d/N]: y 安装成功后开启MySQL服务1systemctl start mysqld 为php和mysql安装依赖1yum install -y php-mysql 最后重启服务器1systemctl restart httpd 至此lamp环境搭建完成]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6规范中的import和export踩坑]]></title>
    <url>%2F2019%2F02%2F19%2F%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%2FES6%E8%A7%84%E8%8C%83%E4%B8%AD%E7%9A%84import%E5%92%8Cexport%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[ES6规范中的import和export踩坑 各浏览器对ES6语法的支持桌面端浏览器对ES2015的支持情况 Chrome：51 版起便可以支持 97% 的 ES6 新特性。 Firefox：53 版起便可以支持 97% 的 ES6 新特性。 Safari：10 版起便可以支持 99% 的 ES6 新特性。 IE：Edge 15可以支持 96% 的 ES6 新特性。Edge 14 可以支持 93% 的 ES6 新特性。（IE7~11 基本不支持 ES6） 移动端浏览器对ES2015的支持情况 iOS：10.0 版起便可以支持 99% 的 ES6 新特性。 Android：基本不支持 ES6 新特性（5.1 仅支持 25%） 服务器对ES2015的支持情况 Node.js：6.5 版起便可以支持 97% 的 ES6 新特性。（6.0 支持 92%） import和export的用法export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口 import用于在一个模块中加载另一个含有export接口的模块。 也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）index.html:123456&lt;script type=&quot;module&quot;&gt; import &#123;foo, num&#125; from &apos;./test.js&apos;; console.log(num); console.log(foo());&lt;/script&gt; test.js:12export const num = &apos;123&apos;;export function foo() &#123; return &apos;456&apos;;&#125; 注意事项注意: 浏览器要选择兼容ES6的版本（上文有对照表） 要使用ES6语法需要在script引用标签中加入 type=”module”来向浏览器声明要使用ES6语法。 type=”module” 默认不支持跨域，所以在本地浏览器不能使用import和export,需要搭建服务器环境。]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于DeepFaceLabTorrent的人脸替换]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E5%9F%BA%E4%BA%8EDeepFaceLabTorrent%E7%9A%84%E4%BA%BA%E8%84%B8%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[震惊！一男子竟当众变成钢铁侠！ 什么是DeepFaceLabTorrentDeepFaceLab是一种利用深度学习识别和交换图片与视频中脸部的工具。 要注意的是你的GPU得是N系显卡,AMD的各位要去下载CPU版本进行训练。 优点：可手动调整每帧中的脸部识别，减少提取脸部时的错误mt模式下训练出的效果很好，脸部贴合度高可选择的训练模式较多有集成环境版本，只需正确安装驱动即可使用，无需单独搭建环境，对非专业人士较友好缺点：mt模式的训练时间较长，但最后效果最好 DeepFaceLab的安装前往github下载下载并解压后无需配置系统变量，只需安装有显卡驱动就可以进行训练了 准备素材需要准备两个视频 一个是data_dst(需要被换脸的原视频) 一个是data_src(换脸的素材)。需要注意的是为了减少人工操作，视频中的人物最好是一个并且脸部不能有遮挡。准备好视频并放在workspace目录下。 将换脸素材分解成图片 为了换脸成功我们需要要替换脸的尽可能多的情况，一般是选择分解成每秒10帧，如果视频过短也可以选择全帧数分解。(保证分解出900-1200张图片) 分解完成后需要找到不包含人脸的图片并将其删除。 将图片中的人脸提取出来 识别人脸官方提供了两种方案 DLIB和MTDLIB学习速度快但效果差 MT学习速度慢但效果好，大家可以根据自己的硬件配置选择合适的方案。 看看识别出的人脸有没有相似的，有的话就删除，这会大大提高之后训练的速度。 将原视频分解成图片并识别人脸 这里的选择是唯一的，因为要将原视频全部替换，所以是全帧分解。 和之前一样根据GPU的情况选择合适的方案 开始训练 这些方案是按对显存要求递增排序的，如果你的显卡的显存高最好是选择H128以下的方案。实测移动平台的MX150 2G满血版(相当于桌面级的GTX650Ti)比 GTX1060 4G满血版的平均单次迭代时间差了3倍，分别使用了对显存要求1G+的H64 和 要求2G+的H128两种方案。 迭代了6万次后（大约花了15个小时，笔记本真的是有点勉强了）可以看出换脸的效果不错，这时候我们就可以使用这个模型为之前识别出的人脸进行替换了。 应用模型 需要注意你在训练时使用了什么方案，这里就要选择对应的转换方案。 输出视频 可以选择输出为avi或者mp4格式，这里要耗费的时间和视频的长度成正比。 换脸结果原视频： 换脸后的视频：]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[告知]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F%E5%91%8A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[!! 因为七牛云回收了存储空间，本站所有图片丢失，现将有备份的图片转存至了picg.cc!]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>-杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客迁移踩坑总结]]></title>
    <url>%2F2018%2F06%2F16%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[博客迁移至coding的踩坑总结 原因 手误删除了github上的项目地址,重新上传的速度感人,上了梯子也不过10kb/s o(╥﹏╥)o 原来用https的方式push项目不够安全(只要有人知道你的账号密码就能推送) coding由于是国内的服务商,下载上传都能满带宽,而且也同GitHub一样有Pages服务,于是就成了迁移静态网站的首选 过程注册一个coding账号 可以选择用腾讯云账号、Github或者是QQ登陆实在是很方便 新建一个项目 与Github如出一辙的方式,需要注意的是如果想和Github一样通过 &lt;用户名&gt;.github.io 域名来访问Pages的话,coding所建的项目也必须写成&lt;用户名&gt;.coding.me 使用更为安全的ssh方式进行项目的推送ssh简介 SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 ssh验证方式 从客户端来看，SSH提供两种级别的安全验证。第一种级别（基于口令的安全验证）只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。第二种级别（基于密匙的安全验证）需要依靠密匙，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒 [2] 。 coding上的ssh验证 只要添加个人公钥，持有私钥和公钥的设备就能获得coding账户下所有项目的推送权限 生成ssh 1ssh-keygen 使用ssh-keygen来生成私钥公钥 连按3下回车跳过密码，确认密码和注释 当然你也可以设置密码和注释 生成的私钥文件默认存储在c盘/用户/你当前登陆的微软账号或者是本地账户名/.ssh 我们需要的是后缀名为public的公钥，用记事本打开文件，将其中的内容复制到coding的个人ssh中即可，名字可以任取 使用ssh方式推送的注意事项 如果你使用git clone 拉取coding上的项目时，不能使用 https而是用ssh方式拉取，否则会出现没有推送权限的情况 coding Pages 与Github Pages 相同的服务，只要将静态网页推送到项目中就可以在Pages中开启，可以参考一下之前的文章传送门 不过coding推荐使用Jekyll来部署网站，之前没有用过，改天再尝试一下,hexo的加载速度还是有点慢的 (#^.^#) 总结coding最近推出了一款cloudstudio的产品，与腾讯云主机合作可以在线编辑项目代码，等有功夫尝试一下 O(∩_∩)O哈哈~]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>-杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery实现透视镜]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%2Fjquery%E5%AE%9E%E7%8E%B0%E9%80%8F%E8%A7%86%E9%95%9C%2F</url>
    <content type="text"><![CDATA[jquery实现透视镜--揭示隐藏在屏幕后的真相吧 效果展示 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 实现效果:图片默认隐藏 移动鼠标，在鼠标位置附近显示隐藏的内容 --&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;UTF-8&quot;&gt; &lt;style&gt; *&#123; padding: 0px; margin: 0px; &#125; .monitor&#123; margin-left: 100px; height: 200px; width: 200px; border-radius: 50%; overflow: hidden; &#125; .monitor&gt;img&#123; position: relative; left: 0px; top: 0px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;!--为body添加鼠标移动事件，并传入活动对象 --&gt; &lt;body onmousemove=&quot;e(event)&quot;&gt; &lt;div class=&quot;monitor&quot;&gt; &lt;img src=&quot;1.png&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot; &gt; var monitor = document.getElementsByClassName(&quot;monitor&quot;); var img = document.getElementsByTagName(&quot;img&quot;); function e(e)&#123;//接受传入的对象 //获取鼠标位置 var x = e.clientX; var y = e.clientY+ document.documentElement.scrollTop; //图片相对当前定位 要求图片始终固定在原点位置 img[0].style.left=-x; img[0].style.top=-y; //透视镜跟随鼠标移动 monitor[0].style.marginLeft = x-100; monitor[0].style.marginTop = y-100; &#125;; &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3实现精灵球]]></title>
    <url>%2F2018%2F02%2F11%2F%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%2Fcss3%E5%AE%9E%E7%8E%B0%E7%B2%BE%E7%81%B5%E7%90%83%2F</url>
    <content type="text"><![CDATA[纯css3实现精灵球晃动效果 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;UTF-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0px; padding: 0px; &#125; @keyframes anim&#123; 0%&#123;transform: rotate(0deg);&#125; 25%&#123;transform: rotate(30deg);&#125; 50%&#123;transform: rotate(0deg);&#125; 75%&#123;transform: rotate(-30deg);&#125; 100%&#123;transform: rotate(0deg);&#125; &#125; @keyframes anim2&#123; 0%&#123;background: white;&#125; 100%&#123;background: red;&#125; &#125; div&#123; position: relative; height: 300px; width: 300px; border-radius: 150px; margin: auto; margin-top: 200px; background: linear-gradient(red 0%,red 47%,black 47%,black 53%,white 53%,white 100%); box-shadow: 0px 0px 22px #666; animation: anim 3s infinite; &#125; div:before&#123; content: &quot;&quot;; display: inline-block; height: 80px; width: 80px; background: white; border-radius: 40px; position: absolute; bottom: 110px; left: 110px; box-shadow: 0px 0px 0px 20px black inset; animation: anim2 1s infinite alternate; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 实现效果]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D开发(五)]]></title>
    <url>%2F2017%2F10%2F28%2FUnity3D%E5%BC%80%E5%8F%91%2FUnity3D%E5%BC%80%E5%8F%91-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[漫游摄像机 漫游相机FreeCamera.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using UnityEngine;using System.Collections;public class FreeCamera : MonoBehaviour&#123; private Vector3 rota; public float x_speed = 50f; public float y_speed = 50f; public float m_speed = 10f; public float f_speed = 10f; public float h_speed = 1f; public float groundDis = 5f; public float skyDis = 50f; public Camera camera; // Use this for initialization void Start() &#123; rota = camera.transform.eulerAngles; &#125; // Update is called once per frame void Update() &#123; //鼠标右键 if (Input.GetMouseButton(1)) &#123; rota.y += Input.GetAxis(&quot;Mouse X&quot;) * x_speed; rota.x -= Input.GetAxis(&quot;Mouse Y&quot;) * y_speed; Quaternion q = Quaternion.Euler(rota); camera.transform.rotation = q; &#125; //滚轮滑动 float middle = Input.GetAxis(&quot;Mouse ScrollWheel&quot;); camera.transform.position += -Vector3.up * middle * m_speed + (Vector3.forward * middle * f_speed); //空格 if (Input.GetKey(KeyCode.Space)) &#123; middle = -0.01f; camera.transform.position += -Vector3.up * middle * m_speed + (Vector3.forward * middle * f_speed); &#125; //WASD float h = Input.GetAxis(&quot;Horizontal&quot;); float v = Input.GetAxis(&quot;Vertical&quot;); camera.transform.position += camera.transform.right * h * h_speed; camera.transform.position += camera.transform.forward * v*0.2f; clamp(); &#125; private void clamp() &#123; Vector3 upUp; upUp = camera.transform.position; upUp.y = Mathf.Clamp(upUp.y, groundDis, skyDis); camera.transform.position = upUp; &#125;&#125;]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D开发(四)]]></title>
    <url>%2F2017%2F10%2F19%2FUnity3D%E5%BC%80%E5%8F%91%2FUnity3D%E5%BC%80%E5%8F%91-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[Unity3d实现目标追踪 前言在合金装备5 幻痛中玩家可以自己定义目标地点，标记会显示目标与玩家的大致方向和距离 Unity实现使用两个脚本来实现目标追踪 CreatMark.cs 挂载在想要追踪的目标身上 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;public class CreatMark : MonoBehaviour &#123; //自己定义一个UGUI的image并在其中添加text文本用来显示距离 public GameObject mark; //确保场景中存在UGUI的根节点 private GameObject canvans; // Use this for initialization void Start () &#123; canvans = GameObject.Find(&quot;Canvas&quot;); GameObject g = Instantiate(mark); //sendmessage传递当前脚本的载体的Transform g.SendMessage(&quot;getTarget&quot;,transform); g.transform.SetParent(canvans.transform); &#125; &#125; CArrowLookAt.cs用来控制目标追踪UI 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class CArrowLockAt : MonoBehaviour&#123; public Transform target; //目标 public Transform self; //自己 public Text text; public float direction; //箭头旋转的方向，或者说角度，只有正的值 public Vector3 u; //叉乘结果，用于判断上述角度是正是负 float devValue = 10f; //离屏边缘距离 float showWidth; //由devValue计算出从中心到边缘的距离（宽和高） float showHeight; // 初始化 void Start() &#123; //获取标记上的文本组件 text = gameObject.GetComponentInChildren&lt;Text&gt;(); // 获取主摄像机的Transform self = GameObject.Find(&quot;PlayerCamera&quot;).GetComponent&lt;Transform&gt;(); showWidth = transform.parent.GetComponent&lt;RectTransform&gt;().rect.width / 2 - devValue; showHeight = transform.parent.GetComponent&lt;RectTransform&gt;().rect.height / 2 - devValue; &#125; void Update() &#123; if (target) &#123; //更新距离 if (Time.frameCount % 10 == 0) if (target &amp;&amp; self) &#123; text.text = (int)Vector3.Distance(target.transform.position, self.transform.position) + &quot;m&quot;; &#125; // 每100帧都重新计算一次 if (Time.frameCount % 100 == 0) &#123; showWidth = transform.parent.GetComponent&lt;RectTransform&gt;().rect.width / 2 - devValue; showHeight = transform.parent.GetComponent&lt;RectTransform&gt;().rect.height / 2 - devValue; &#125; // 计算向量和角度 Vector3 forVec = self.forward; //计算本物体的前向量 Vector3 angVec = (target.position - self.position).normalized; //本物体和目标物体之间的单位向量 Vector3 targetVec = Vector3.ProjectOnPlane(angVec - forVec, forVec).normalized; //这步很重要，将上述两个向量计算出一个代表方向的向量后投射到本身的xy平面 Vector3 originVec = self.up; direction = Vector3.Dot(originVec, targetVec); //再跟y轴正方向做点积和叉积，就求出了箭头需要旋转的角度和角度的正负 u = Vector3.Cross(originVec, targetVec); direction = Mathf.Acos(direction) * Mathf.Rad2Deg; //转换为角度 u = self.InverseTransformDirection(u); //叉积结果转换为本物体坐标 // 给与旋转值 //transform.rotation = originRot * Quaternion.Euler(new Vector3(0f, 0f, direction * (u.z &gt; 0 ? 1 : -1))); // 计算当前物体在屏幕上的位置 Vector2 screenPos = Camera.main.WorldToScreenPoint(target.position); //if(Vector3.Dot(forVec, angVec) &lt; 0) // 不在屏幕内的情况 if (screenPos.x &lt; devValue || screenPos.x &gt; Screen.width - devValue || screenPos.y &lt; devValue || screenPos.y &gt; Screen.height - devValue || Vector3.Dot(forVec, angVec) &lt; 0) &#123; Vector3 result = Vector3.zero; if (direction == 0) //特殊角度0和180直接赋值，大家知道tan90会出现什么结果 &#123; result.y = showHeight; &#125; else if (direction == 180) &#123; result.y = -showHeight; &#125; else //非特殊角 &#123; // 转换角度 float direction_new = 90 - direction; float k = Mathf.Tan(Mathf.Deg2Rad * direction_new); // 矩形 result.x = showHeight / k; if ((result.x &gt; (-showWidth)) &amp;&amp; (result.x &lt; showWidth)) // 角度在上下底边的情况 &#123; result.y = showHeight; if (direction &gt; 90) &#123; result.y = -showHeight; result.x = result.x * -1; &#125; &#125; else // 角度在左右底边的情况 &#123; result.y = showWidth * k; if ((result.y &gt; -showHeight) &amp;&amp; result.y &lt; showHeight) &#123; result.x = result.y / k; &#125; &#125; if (u.z &gt; 0) result.x = -result.x; &#125; transform.localPosition = result; &#125; else // 在屏幕内的情况 &#123; transform.position = screenPos; &#125; &#125; else &#123; //标记被清除时销毁自身 Destroy(gameObject); &#125; &#125; //获取目标的Transform组件 创建该GameObject时在 CreatMark 中调用 public void getTarget(Transform t) &#123; target = t; Vector3 t2 = new Vector3(0,0,0); t2 = t.position; //对于新增的标记将y轴坐标增大到玩家视线平面 if (t2.y &lt;= 0) t2.y += 33; target.position = t2; &#125;&#125; 实现效果:]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D开发(三)]]></title>
    <url>%2F2017%2F10%2F13%2FUnity3D%E5%BC%80%E5%8F%91%2FUnity3D%E5%BC%80%E5%8F%91-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Unity3d中制作异步Loading进度条所遇到的问题(转载) 背景通常游戏的主场景包含的资源较多，这会导致加载场景的时间较长。为了避免这个问题，可以首先加载Loading场景，然后再通过Loading场景来加载主场景。因为Loading场景包含的资源较少，所以加载速度快。在加载主场景的时候一般会在Loading界面中显示一个进度条来告知玩家当前加载的进度。在Unity中可以通过调用Application.LoadLevelAsync函数来异步加载游戏场景，通过查询AsyncOperation.progress的值来得到场景加载的进度。 尝试——遇到问题第一步当加载完Loading场景后，调用如下的LoadGame函数开始加载游戏场景，使用异步加载的方式加载场景1(Loading场景为0，主场景为1)，通过Unity提供的Coroutine机制，我们可以方便的在每一帧结束后调用SetLoadingPercentage函数来更新界面中显示的进度条的数值。 1234567891011public void LoadGame() &#123; StartCoroutine(StartLoading_1(1));&#125;private IEnumerator StartLoading_1(int scene) &#123; AsyncOperation op = Application.LoadLevelAsync(scene); while(!op.isDone) &#123; SetLoadingPercentage(op.progress * 100); yield return new WaitForEndOfFrame(); &#125; &#125; 最后进度条的效果显示如下: 进度条并没有连续的显示加载的进度，而是停顿一下切换一个数字，再停顿一下切换一个数子，最后在没有显示100%就情况下就切换到主场景了。究其原因在于Application.LoadLevelAsync并不是真正的后台加载，它在每一帧加载一些游戏资源，并给出一个progress值，所以在加载的时候还是会造成游戏卡顿，AsyncOperation.progress的值也不够精确。当主场景加载完毕后Unity就自动切换场景，所以上述代码中的while循环体内的代码是不会被调用的，导致进度条不会显示100%。 修补——100%完成为了让进度条能显示100%，取巧一点的办法是将AsyncOperation.progress的值乘上2，这样当加载到50%的时候界面上就显示100%了。缺点是当界面上显示100%的时候，用户还要等待一段时间才会进入游戏。其实Unity提供了手动切换场景的方法，把AsyncOperation.allowSceneActivation设为false就可以禁止Unity加载完毕后自动切换场景，修改后的StartLoading_2代码如下: 12345678910// this function is not workprivate IEnumerator StartLoading_2(int scene) &#123; AsyncOperation op = Application.LoadLevelAsync(scene); op.allowSceneActivation = false; while(!op.isDone) &#123; SetLoadingPercentage(op.progress * 100); yield return new WaitForEndOfFrame(); &#125; op.allowSceneActivation = true; &#125; 我们首先将AsyncOperation.allowSceneActivation设为false，当加载完成后再设为true。代码看上去没有错，但是执行的结果是进度条最后会一直停留在90%上，场景不会切换。通过打印log发现AsyncOperation.isDone一直为false，AsyncOperation.progress的值增加到0.9后就保持不变了，也就是说场景永远不会被加载完毕。 在这个帖子中找到了答案，原来把allowSceneActivation设置为false后，Unity就只会加载场景到90%，剩下的10%要等到allowSceneActivation设置为true后才加载，这不得不说是一个坑。所以代码改为如下。当AsyncOperation.progress到达0.9后，就直接把进度条的数值更新为100%，然后设置AsyncOperation.allowSceneActivation为ture，让Unity继续加载未完成的场景。 1234567891011private IEnumerator StartLoading_3(int scene) &#123; AsyncOperation op = Application.LoadLevelAsync(scene); op.allowSceneActivation = false; while(op.progress &lt; 0.9f) &#123; SetLoadingPercentage(op.progress * 100); yield return new WaitForEndOfFrame(); &#125; SetLoadingPercentage(100); yield return new WaitForEndOfFrame(); op.allowSceneActivation = true; &#125; 最后的效果如下： 打磨——增加动画上述的进度条虽然解决了100%显示的问题，但由于进度条的数值更新不是连续的，所以看上去不够自然和美观。为了看上去像是在连续加载，可以每一次更新进度条的时候插入过渡数值。这里我采用的策略是当获得AsyncOperation.progress的值后，不立即更新进度条的数值，而是每一帧在原有的数值上加1，这样就会产生数字不停滚动的动画效果了，迅雷中显示下载进度就用了这个方法。 12345678910111213141516171819202122private IEnumerator StartLoading_4(int scene) &#123; int displayProgress = 0; int toProgress = 0; AsyncOperation op = Application.LoadLevelAsync(scene); op.allowSceneActivation = false; while(op.progress &lt; 0.9f) &#123; toProgress = (int)op.progress * 100; while(displayProgress &lt; toProgress) &#123; ++displayProgress; SetLoadingPercentage(displayProgress); yield return new WaitForEndOfFrame(); &#125; &#125; toProgress = 100; while(displayProgress &lt; toProgress)&#123; ++displayProgress; SetLoadingPercentage(displayProgress); yield return new WaitForEndOfFrame(); &#125; op.allowSceneActivation = true;&#125; displayProgress用来记录要显示在进度条上的数值，最后进度条的动画如下： 对比第一种的进度条 总结如果在加载游戏主场景之前还需要解析数据表格，生成对象池，进行网络连接等操作，那么可以给这些操作赋予一个权值，利用这些权值就可以计算加载的进度了。如果你的场景加载速度非常快，那么可以使用一个假的进度条，让玩家看上几秒钟的loading动画，然后再加载场景。总之进度条虽然小，但要做好也是不容易的。]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D资源合集]]></title>
    <url>%2F2017%2F09%2F23%2FUnity3D%E8%BF%9B%E9%98%B6%2FUnity3D%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[常用插件与模型资源 插件天气插件Enviro - Sky and Weather 1.9.0 Sky and Weather azureSky 2.0.1 azureSky 2.0.1 雨特效插件 RainMaker RainMaker 雪特效插件 Realistic Hail Set Realistic Hail Set skybox天空盒Skybox 树木与花草grass tree 后期处理post-Processing post 相关教程链接:post 地形贴图地形贴图 粒子特效粒子特效 人物模型英雄联盟艾希 艾希 Adam Adam 该文章长期更新Unity资源及相关插件使用教程]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D开发(二)]]></title>
    <url>%2F2017%2F09%2F16%2FUnity3D%E5%BC%80%E5%8F%91%2FUnity3D%E5%BC%80%E5%8F%91-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Unity5光照系统详解(官方教程) 简介全局光照，简称GI，是一个用来模拟光的互动和反弹等复杂行为的算法，要精确的仿真全局光照非常有挑战性，付出的代价也高，正因为如此，现代游戏会先一定程度的预先处理这些计算，而非游戏执行时实时运算。 同一场景里：没有照明(左)，只有直接光源(中)，和有间接光源的全局光照(右)的表现，注意颜色如何在不同的表面进行光的”反弹”，产生更真实的结果。 在本文中，我们会描述全局光照如何在Unity里运作，带领你通过不同的照明技术解释如何在项目里设定照明，并思考如何透过各种工具帮场景打光。 选择一个照明专案广义的来说，Unity的全局光照是”实时”或是”预先计算好”的，在某些情况下两种方法可以结合使用，照出更逼真的场景。本节我们会针对两种技术的差异优势和使用时机做个简单的描述。 实时照明(REALTIME LIGHTING)预设情况下，Unity的灯源(直接光源, 投射灯, 点光源)都是实时的，代表这些灯源会把光线照射到场景并以每一帧的频率更新，由于光源是可以在场景内移动的对象，场景灯光的更新是实时的，你可以在游戏窗口和场景窗口看到改变。 实时照明的影响：注意到因为没有反射光源的关系阴影是全黑的，只有投射光锥体范围内的对象表面才有光源影响。 实时照明是场景里照亮物体最基本的方法，用来照亮角色和会动的对象，可惜的是，Unity实时照明里的光线不会反射，因此我们才导入了全局光照系统，启用了预先计算的技术，都是为了表现一个更逼真的场景。 烘焙全局光照(BAKEDGI LIGHTING）当烘焙一张光照贴图(Lightmap)时，场景内的静态对象会基于光的影响算出一张贴图成果，并迭在场景对象之上建立照明效果： 左：一个简单的光照贴图场景成果，右：由Unity产生的一张光照贴图(阴影和光源信息都被纳入计算) 这些”光照贴图”可以包含场景内投射到物体表面的直接光源，以及在不同物体间反射的”间接光源”，这样的光照贴图可以透过物体材质上的着色器(Shader)描述像是颜色的表面信息(Albedo)和凹凸(Normals)信息。 烘焙光照所产生出来的贴图，是无法在游戏运作的时候变更运算的，因此被定义为静态(Static)，虽然仍可在这层贴图上继续迭加光源计算，但两者已无法交互运算，通常我们采用这光照法来让低阶的手机能顺利执行，解决光在游戏中运行的效能问题。 预计算全局光照(PRECOMPUTED REALTIME GI LIGHTING)虽然传统的静态光照贴图无法在游戏执行时改变场景光照条件，但预先计算的实时全局光照系统能帮我们实时运算复杂的场景光源互动，透过这种方法，就能建立昏暗的环境带有丰富的全局光照反射，并实时反映光源的改变。好比做个日晷，阴影的位置和颜色会随着光源移动改变，这在原本的烘焙光照系统是无法达成的。 一个用GI呈现的日晷案例 为了在合理的帧率实现这些效果，我们需要在实时运算之前先将一堆垄长的数字数据做”预计算”，预计算负责计算游戏过程中光的复杂行为，它可以在时间空档时进行计算，我们称作一个”脱机”运算。 如何运作？最常见的需求是我们希望间接光源能够列入场景光照贴图的计算，幸好，原理上这些间接光源都是从直接光源慢慢转变过来的颜色，只有少部分特定情况有比较大幅度的颜色改变，这样的Unity的全局光照预计算，利用间接光源漫反射(diffuse)特性对运算有利。通常好的阴影是透过即时光源所计算出来的，而非烘焙到光照贴图，假定我们并不需要太复杂的细节取样，可以大大降低全局光照所产生的数据大小。 透过预计算来简化整个流程，有效的降低了原本要在游戏中实时计算的全局光照运算数量，如果你要常在游戏中改变光源颜色，旋转光源或是调整光的强度，甚至对场景表面做变更，这点就很重要。Unity从表面上采样底层贴图，并从广义定义颜色的值到一个大型的群组，或是”丛集”，这会产生一个低解析的仿真静态几何，以方便我们用来计算光照。 左：场景显示设置为”Albedo”时，可以清楚看到由Unity预计算所产生的纹理；右：如同游戏的场景一样，即时光照计算完结果后套用到场景。 基本上，当在计算全局光照时，我们会针对静态场景周围做”光迹追踪”运算，这是非常耗效能的，因此无法苛求要实时运算，相反的，Unity把光迹追踪用在计算这些表面的丛集关系 - 在预计算”光传输”的阶段，然后把世界串成一个网络结构，我们在关键性的游戏过程就不再需要耗费效能的光迹追踪法。 我们有效的创造出一个简化的算法可以在游戏过程中变化输入结构，这代表我们可以改变光源或是表面颜色，并很快的看到场景内全局光照的影响，算出的结果产出光照贴图透过GPU着色，并和其他照明或是表面混合，最后输出到屏幕上。 收益和成本(BENEFITS AND COSTS)虽然可以同时使用烘焙方式的GI和预计算的GI，但要注意是同时仿真两个系统，效能负担也会两次运算的总和，不只是因为要储存两套光照贴图在显卡内存，同时着色器也得付出两次的处理成本。 最终要选择哪个方法还是要取决于你项目的性质和预期的硬件考虑，例如在手机平台上，效能和内存限制较高，烘焙的GI法就会比较适合，如果是在有显卡的计算机上或是游戏机上执行，那可能使用预计算实时全局光照，或两个同时使用就比较可行。决定采用哪一种方法可以针对你的目标平台评估，记得如果项目要同时符合几个不同的硬件需求，往往都是以效能最高的平台为考虑。 预先计算的过程(THE PRECOMPUTE PROCESS)在Unity里，预计算是在背景执行，不管是自动流程或是手动启用，计算期间你都可以继续编辑你的游戏对象而不受影响，预计算的时候会在右下角出现一个进度条，不同的算法会有不同的运算阶段，进度条上方也会显示阶段名称与进度。 从上面的例子可以看出，11个工作已经进展到第5个，”丛集”还有108件工作要执行完才会到第6个会话，数值状态栏表如下： 启用一个预计算(STARTING A PRECOMPUTE)只有静态对象会被纳入GI预计算，要让预计算启动首先必须最少要有一个静态对象，不管是单独设定对象或是从层级选单用Shift + 选择多个对象后一次修改。 从属性面板，将对象的Static勾选起来，这会将该物体所有跟静态对象相关的旗标打开，包含导航旗标或是批处理旗标，这或许不是你想要的，针对预计算只要把”Lighting Static”这个旗标打勾即可。更细部的控制，只要点选属性接口Static右边的下拉式选单即可，此外，从Window里的Lighting接口也能指定设定静态对象。 如果你的场景设为自动(Lighting-&gt;Scene-&gt;Auto)，Unity的预计算就会自动启动，否则就需要用下列的流程手动执行。 自动/手动预计算(AUTO/MANUALPRECOMPUTE)假如Lighting接口底下Auto这个选项是被勾选的(Lighting-&gt;Scene-&gt;Auto)，那么预计算就会自动在背景不停的改变场景产出的静态几何。但如果这个勾选没勾，你将需要点击在Auto旁边的”Build”按钮手动启动预计算，这会用同样的方式进行预计算，让你比较好控制计算的开始时间。手动启动预计算会对场景所有的照明与各方面进行重新评估并重新计算，如果你希望有选择性的计算，可以从”Build”旁边的下拉选单来选择。 使用烘焙GI或是预计算GI（ENABLINGBAKED GI OR PRECOMPUTED REALTIME GI） 预设情况下，两种计算法在Unity里都是启用状态(Lighting-&gt;Scene)，因为如此，你可以针对单独的光源设定要采用哪种计算法(Inspector-&gt;Light-&gt;Baking) 在一个场景同时采用两种方法可能会对效能造成负担，最好的做法在同一个时间只用一种方法，要关闭任何一种方法可以从GI的接口(Lighting-&gt;Scene)，把不要用的方法取消打勾即可，只有有打勾的算法会计算，任何相关光的设定都会被覆盖。 (PRE-LIGHTSETTINGS)Unity里每盏灯光默认的烘焙模式都是”Realtime”，这代表这些灯光仍然会照亮你的场景，Unity的预计算GI系统会处理间接光。但如果默认的烘焙模式是”Baked”，那么这些灯光将会透过Unity的烘焙GI系统处理直接光源和间接光源，产生出来的光照贴图一旦贴到场景上在执行期间是不能改变的。 一个设定烘焙模式为”Realtime”的点光源 选择烘焙模式为”Mixed”的话，场景内的静态对象会被烘焙GI拿去做计算，然而，不像”Baked”模式，混合模式的灯光仍会继续运算即时光源到非静态对象上，这对于你想把静态环境烘成光照贴图，但同时又希望同样一盏灯能为会动的角色计算阴影很有帮助。 GI快取(GI CACHE)无论是烘焙还是预计算系统，Unity会”缓存”场景的光照数据到”GI快取”，并会在计算时尝试重复运用这些数据来节省时间，你对场景的改变会影响这个数据重复利用的多寡。 如果你要清除这个快取可以从(Preference-&gt;GICache-&gt;Clear Cache)来清除，清除后代表所有数据都必须重新运算，因次会花费一些时间，在某些情况下你也许需要降低档案空间大小(例如要把项目转到另外一台计算机)是有帮助的。 场景设定(SCENESETUP)选择着色路径(CHOOSING A RENDERING PATH)Unity支持许多著色技术或”路径”，在启动一个项目时，必须要订出出一个路线，Unity预设是”Forward Rendering”。在”ForwardRendering”里，每个对象著色是根据每个影响对象的光，透过”Pass”来著色，所以有可能一个对象被重复著色了好几次，取决于有几盏灯在作用范围里。 这种方法的优点是快速，也代表硬件需求低，此外，这种正向著色提供了广泛的自定义”着色模型”，可以快速处理透明度，也支持像是多重采样柔边(MSAA)的硬件功能，等等有些在其他路径上是无法实现的功能，对于图形质量有很大的影响。 然而他的缺点是要为每盏灯光付出相对应的成本，也就是说，对象被越多盏灯光影响，花费的运算成本就越高，有些类型的游戏必需要大量的光源，就会令人望之却步，反观如果你能管理好你的灯光数量，那这个路径会是一个非常快速的解决方案。 “Deferred”路径是延迟了光的遮蔽与混合信息直到第一次接收到的表面的位置 法线 以及材质数据著色到一个”几何缓冲器”(G-buffer)作为一个屏幕空间的贴图，最后合成这些结果，这种方法优点是照明的著色成本是和像素数量成正比，而非灯光数量，因此你不用再管控场景灯光数量，某些游戏类型将会是一个关键优势。 “Deferred”路径呈现可预见的效能特点，但通常需要较强大的硬件，对于手机平台支持度也较低。 关于”Deferred”,”Forward”或是其他路径的更多信息，可以参阅这里。 选择一个色彩空间(CHOOSING A COLOR SPACE)除了要选好著色路径之外，一开始选择一个”色彩空间(Color Space)”也是很重要的事情，色彩空间决定采用哪种算法来计算照明或材质加载时的颜色混合，这会对游戏的画面真实感有很大的影响，但大多数情况下，太超过的色彩空间设定可能会被目标平台的硬件强制限制。 推荐比较接近真实的色彩空间是Linear，你可以从PlayerSetting里面找到”Color Space”来设定(Edit-&gt;ProjectSetting-&gt;Player) 设定Linear的优点是会让场景内的提供给着色器的颜色也会因为光强度增加变亮，如果换成”Gamma”色彩空间，亮度马上会转为以白色做为参考，这将不利于图像的质量。 采用Linear和Gamma颜色空间的图像对照表，可以注意到切换成Gamma时颜色快速的换成以白色为光照强度为基准。 Linear另一个好处是着色器能在没有Gamma补偿的情况下对贴图进行取样，这有助于确保颜色质量在经过著色管道还能保持一致性，能提高色彩和计算的精度，最后屏幕的输出结果更为真实。可惜的是Linear颜色空间有些手机平台甚至有些游戏机不支持，应该说PC或是一些新手机硬件和次世代游戏机才会支持Linear颜色空间，在这种情况下，就得用Gamma方法替代了。 确认你的目标平台是哪一种之后才选择适合的颜色空间是很重要的，想要了解更多关于颜色空间的信息，可以参阅这里。 高动态范围(HDR)如同颜色空间，相机的”Dynamic range”动态范围是需要指定的，从本质上来说，这是用来定义相机截取的最亮与最暗的颜色范围，要启用HDR可以从相机组件里把HDR项目打勾即可，要注意的是，某些手机硬件是不支持HDR的，在著色路径为ForwardRendering并启用MSAA柔边时也不支援HDR，HDR和Linear颜色空间一起搭配是最好的，在处理非常明亮的颜色的时候还能保有准确性。 在默认的情况下，Unity是使用低动态范围(LDR)，颜色会以每个频道8位储存三原色(红 绿 蓝)，8位确切的意思是用8个0或1的数字组合成的值，一共会有256种组合，三个频道256 x256 x 256可以组合出1600万种色采来表达从黑色到白色不同层度的灰阶。 在现实环境中，颜色远远超出1600万个色阶，颜色和亮度的排列甚至远远超越了我们人眼所能辨识的，同样的，Unity能够处理超出这些范围的颜色并输出高于LDR设备支持的颜色，用来提供给像是计算机画面的高质量结果，尽管现今输出装置仍有很多限制，这些多出来的数值仍然可有很多的应用。启用HDR之后，会储存更大精度的颜色资料(使用浮点运算表示)，能处理更多更亮的颜色范围。 HDR能让我们在同一画面下维持两个巨大差异的亮度，例如场景的阴影区域和户外的亮光，我们也可以在环境场景建立一个”光晕”或发光特效，透过这些特效或可视的光影效果能增加画面的真实感，但也要小心处理这些效果以防止他们曝光过度。 色调映射(TONEMAPPING)以摄影来比喻的话，如果我们使用不同的曝光度来拍摄我们的场景，我们可以先观察到哪些颜色会因为曝光过度而遗失，浅色调在很亮的区域可能被白色给覆盖过去，暗色调可能会被黑色给覆盖，这像是计算机图学的”色调映像”，当颜色在显示设备(比如计算机屏幕)表现范围之外时，算法会将颜色修正为装置合理的颜色并重现在屏幕上，当相机启用HDR时，建议相机加入Tonemapping这只程序(Assets-&gt;ImportPackage-&gt;Effects)，这只程序可以帮你转换控制超出范围的颜色成为合理的颜色。 更多关于色调映像的数据可以查看这里。 环境光(AmbientLighting)场景中一个照亮整体环境非常重要的就是”环境光”，可以说是影响场景光源最全面的一个要素，环境光很多情况都很有用，也取决于你所选的风格，比如卡通风格的阴影不清楚或灯光是手绘风格，环境光也很适合用在当你不想单独调整场景内的灯光但又想要增加整体场景亮度的时候。在没有使用Unity 5全局光照的功能时，环境光不会算出准确的物理遮挡，但如果开启了任何一种GI的情况下，从Skybox照下来的环境光就能被算出遮挡，结果会更加真实。 在同一个场景之下，左边是没有任何光源的场景，右边则开启了环境光，可以注意到调整环境光的强度天空盒的亮度并没有改变。 透过将对象设定为静态对象来启用全局光照的场景，可以注意到光线在不同的表面有遮挡的效果。 使用环境光的好处是耗用效能很低，因此在手机平台上只要灯光数量控制得宜也能得到很好的表现，你可以从Lighting窗口(Window-&gt;Lighting)找到EnvironmentLighting设定区域(Lighting-&gt;Scene)，改变Ambient Source来改变环境光来源。 Ambient Source的默认值是”Skybox”，上图的天空盒是Unity 5系统产生的一个默认天空盒，带有一个蓝色调的环境光，以及一些用该半球体上纯色与渐变色的设定。要注意的是改变Lighting里面的AmbientSource并不会让Skybox的颜色改变，但会影响到场景内环境光照射。 反射源(REFLECTIONSOURCE)默认的情况下，场景中的对象会使用Unity内建的标准着色器(StandardShader)来著色，标准着色器是一个基于物理的着色器(PBS)，它会透过模仿真实世界的物理特性像是反射或能量传递等来模拟真实世界里光在材质上的表现。 当使用标准着色器时，每一个材质都会具有一定程度的镜面反射(specularity)和金属反射(metalness)属性，在没有强大的硬件来处理即时光迹追踪反射的情况下，我们得仰赖预先计算著色反射，我们使用了一个由六张描述天空的图片所组成的方体贴图(Cubemap)或从Unity 5用来从定点搜集环境信息的反射探头(Reflection Probe)产生所需的贴图，然后在和其他光和地表信息混合运算来仿真如同我们真实世界看到的反射效果。 在预设的情况下，调高Specular和Metalness会更清楚的反射天空盒，反射的来源可以从设定来调整。 场景内的对象在默认的情况下会反射天空盒的内容，但你可以从Lighting接口里找到ReflectionSource属性来改变来源，指定一个新的方体贴图，或指定一个反射探头来定义。 反射探头(REFLECTIONPROBES)天空盒的信息不可能包含所有的场景对象，在许多情况下，对象从天空搜集反射信息时可能会被遮蔽，像是室内对象或是在类似桥或是隧道等建筑物里的对象，为了要准确反射这些对象，我们必须用反射探头针对这些对象取样，这种探头从他们的位置对周围取样并把结果写到方体贴图，可以让周围经过的物体得到环境的反射影像。你可以透过GameObject-&gt;Light-&gt;Reflection Probe来新增一个反射探头，反射探头的位置会决定方体贴图取样的内容，以及反射所看起来的样子，一般来说，基于效能考虑反射探头越少越好，请记住，反射探头并非用来让物理得到精确结果，而是让游戏世界有更好的反射，大多数情况下几个安排妥当的反射探头就很足够了。 左图：场景只有预设的反射设定 右图：场景加入了反射探头后的结果 在反射探头的属性面板我们可以设定Type为实时(Realtime),烘焙(Baked)或自定义(Custom)，需要明白的是，实时反射的设定对效能极为不利，每多一个实时反射探头就会多出额外六次的著色运算，因此摆设实时的反射探头应该要有明确的需求，例如反射会闪动的霓虹灯，否则一般来说建议设成烘焙的就够了，效能也会好很多。 需要注意的是，只有标记为”ReflectionProbe Static”的对象才会被反射探头取样，从属性接口上静态对象(Static)的下拉选单打勾即可，相反的，实时的反射探头会对所有可见的物体取样，除非你在屏蔽(Mask)选单指定剔除它。 照亮一个场景(LIGHTINGA SCENE)我们已经介绍了一些在Unity里针对场景照明开始工作之前所需要考虑的条件，希望你对目标平台该用哪些设定已经有了一个方向(手机平台采用烘焙GI和Gamma颜色空间，PC或游戏机采用实时GI和Linear颜色空间)，接下来让我们来看看有哪些协助制定光源的工具。 定向光源(DIRECTIONALLIGHTS)“定向光”非常适合用来模拟阳光，它的特性就像是个太阳，定向光能从无限远的距离投射光源到场景，从定向光发出来的光线是互相平行的，也不会像其他种光源会分岔，结果就是不管对象離定向光源多远，投射出来的阴影看起来都一样，这其实对户外场景的照明很有利。 定向光没有真正的光源坐标，放置在场景任何地点都不会影响光的效果，只有旋转会影响定向光的照射结果。其他有光源坐标的灯光类型，例如投射灯(Spotlights)，角色阴影会因为接近或远离光源而改变，这也许在照亮室内环境时会是个问题，一般来说，避免角色太接近隐形的光源，我们会建立一个亮点来假装光源。 使用定向光不用考虑距离，不管多远它都会影响场景所有的表面(除非被剔除)，当使用延迟(Deferred)著色路径时会造成一些效能损耗，要注意的是，使用这个著色路径时，光的效能代价和他影响的像素数目是成正比的，但虽然需要消耗效能，起码结果较为统一，因此比较容易调整平衡。 在预设情况下，新的场景都会附带一盏定向光，在Unity 5里还会与天空盒系统关联(Lighting-&gt;Scene-&gt;Skybox)，你也可以删除预设的定向光并创建一个新的光源，然后从Sun这个属性重新指定(Lighting-&gt;Scene-&gt;Sun) 旋转预设的定向光会导致天空盒也跟着更新，如果光的角度和地面平行就可以做出日落的效果，把光源转到天空导致变黑就能做出夜晚的效果，从上往下照就会模拟日间的效果。如果天空盒有指定为环境光源(Ambient Source)，那么天空盒的颜色就会影响环境里面的对象。 点光源(POINT LIGHTS)点光源可以想象是在3D空间里一个对着所有方向发射光线的点，很适合用来制作像是灯泡, 武器发光或是从物体发射出来的爆炸效果，点光源的亮度从中心最强一直到范围属性(Range)设定的距离递减到0为止，光的强度从光源到距离成反比，这是所谓的”平方反比定律”，类似光在现实世界的行为。 点光源从它的位置对四面八方射出光线，球形的小图示代表光的”范围”，光线到达此范围是会”衰减”到0，但如果有间接光源或反射光则会继续投射。 点光源开启阴影运算是很耗效能的，因此必须谨慎使用，点光源的阴影为了要给六个不同的世界方向会运算六次，在比较差的硬件开启此功能会造成较大的效能负担。 当在场景中加入点光源时要注意，目前它们不支持阴影的间接反射，这代表由点光源产生的光线，只要在距离内有可能会穿过对象反射到另外一面，这可能会导致墙壁或地板”漏光”，因此放置点光源要格外注意，然而如果是采用Backed GI的话，就不会有这类的问题产生。 聚光灯(SPOTLIGHTS)聚光灯投射一个锥体在他的Z轴前方，这个锥体的宽度由投射角度(Spot Angle)属性控制着，光线会从源头到设定的范围慢慢衰减到0，同时越靠近锥体边缘也会衰减，把投射角度的值加大会让锥体宽度加大，同时也让边缘淡化的力度变大，这现象学名叫做”半影”。 聚光灯有许多用途，他们可以用来模拟路灯, 壁灯,或许多创意用法，例如模拟手电筒，因为投射区域能精确的控制，因此很适合用来模拟打在角色身上的光或是模拟舞台灯光效果等等。光线会因为离源头越远而递减，可以注意到光也会因为越靠近锥体边缘而变弱，我们称之为半影区，这会因为锥体角度变大而更明显。和点光源一样，使用预计算GI时，聚光灯不支持间接光阴影，这表示灯光会穿过几何影响到另外一面，因此放置投射灯要特别注意。 区域光(AREA LIGHTS)区域光可以当作是摄影用的柔光灯，在Unity里面他们被定义为单面往Z轴发射光线的矩形，目前只能和烘焙GI一起使用，区域光会均匀的照亮作用区域，虽然区域光没有范围属性可以调整，但是光的强度也是会随着距离光源越远而递减。 区域光照亮表面并在区间产生漫反射与柔和的阴影 区域光用在建立柔和的照明效果非常有用，光线在任何方向穿过光的表面时会产生不同方向的折射 - 造成在对象上产生漫反射，常见的用途是拿来当作天花板壁灯或是背光灯，为了实现这功能，我们必须从每个光照贴图像素上发射一定数量的光线，背对着区域光以确定光有能见度，这代表区域光的计算是消耗很大的，而且会延长烘焙的时间，但如果运用得宜可以增加场景光的深度，那么消耗就很值得，值得注意的是区域光只能用在烘焙，因此不影响游戏效能。 发光材质(EMISSIVE MATERIALS)虽然区域光不支持实时GI，Unity提供另外一个柔和的灯光效果叫做发光材质(Emissive Materials)，和区域光一样，发光材质可以让物体表面发光，他们可以反射场景内像是颜色或是光强度等等能在游戏内改变的光源，自发光(Emission)是一个在标准着色器(Standard Shader)内的属性，允许静态对象成为一个发光体，预设情况下是0，代表指定了这个材质并不会有任何的自发光反应，HDR颜色选择器能指定发光颜色，强度能在0-1的范围调整，来建立类似区域光的效果。 发光材质并没有范围属性，但从材质发出的光会以二的次方速度递减，自发光材质只会作用在有标记为”Static”或”LightmapStatic”卷标的对象，同样的，如果发光材质附加在非静态对象或像是角色的动态对象则不会有任何作用。 然而，材质设定只要emission数值大于0，即使他们不接收场景光源在画面上也会有发光的效果，这种效果也可以透过将emission属性底下的”Global Illumination”改为”None”，像这样的自发光材质很适合来模拟霓虹灯等类似的光源。 使用Unity标准着色器并附加自发光材质的一个范例，注意从Unity Logo的自发光也会计算阴影，在这个案例让球体有了阴影。 发光材质只会影响场景内的静态对象，如果你想要影响像是角色的动态对象，就必须采用光探头系统(Light Probes)，在游戏周期改变发光材质的值会更新光探头取样，并直接在结果上看到变化。 光探头(LIGHT PROBES)静态对象只被Unity全局光照GI系统计算，为了使动态对象能够和静态场景接收到的光影信息互动，我们需要纪录这些光的信息并做成可以在执行期间快速存取的格式。我们在场景放置许多取样点来截取各个方向搜集来的信息，颜色信息会被编成能在游戏中快速被取出的一组数值(或系数)，这些取样点我们称为”光探头”。 使用了光探头的场景，注意图中光探头放置位置在光线容易变化的地方，例如阴影或是颜色转换的地方。 光探头允许移动对象接受由全局光照GI所计算出来复杂的反射光源，对象在著色网格的时候会判断附近光探头的位置并且把光的信息一并融合计算，这是透过找寻由光探头所产生的一个四面体，然后决定哪个四面体的落入对象的轴向，这样就能让场景内的动态对象正确地接受光信息，如果没有放置光探头，动态对象就无法接受全局光照的信息，造成动态对象比场景还要暗。 预设的情况下，场景是没有任何光探头的，你必须从GameObjects-&gt;Light-&gt;LightProbe Group自行建立光探头群组。假如全局光照里的Auto是打勾的(Lighting-&gt;Scene-&gt;Auto)，当光源或是静态对象更新时，光探头信息也会实时更新，没打勾的话必须点Build运算才会更新。]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c#简单开发(一)]]></title>
    <url>%2F2017%2F09%2F16%2Fc-%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91%2Fc-%E7%AE%80%E5%8D%95%E5%BC%80%E5%8F%91-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[简易计算器开发 开发目标 开发环境：vs2015 使用预制的按钮进行数值的输入 可以进行四则运算 不进行等号计算的情况下自动的进行连算 在得出等号或连算的结果后，下一次从预制按钮获取的数值输入会进行覆盖而非在数值结果的基础上进行加算 开发代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace WindowsFormsApplication1&#123; public partial class Form1 : Form &#123; //储存第一位数 float temp1 = -1; //连续计算标记 int index = 0; //存储符号位 string ch = &quot;&quot;; //结果标记 bool isresult = false; //运算方式标记 int pos = 0; public Form1() &#123; InitializeComponent(); &#125; private void addNum(int num) &#123; //当前标记如果为计算出的结果 则在接收下一次数值按键时进行覆盖操作 if(!isresult) textBox1.Text = textBox1.Text + num.ToString(); else &#123; textBox1.Text = num.ToString(); isresult = false; &#125; &#125; private void button1_Click(object sender, EventArgs e) &#123; addNum(1); &#125; private void button2_Click(object sender, EventArgs e) &#123; addNum(2); &#125; private void button3_Click(object sender, EventArgs e) &#123; addNum(3); &#125; private void button4_Click(object sender, EventArgs e) &#123; addNum(4); &#125; private void button5_Click(object sender, EventArgs e) &#123; addNum(5); &#125; private void button6_Click(object sender, EventArgs e) &#123; addNum(6); &#125; private void button7_Click(object sender, EventArgs e) &#123; addNum(7); &#125; private void button8_Click(object sender, EventArgs e) &#123; addNum(8); &#125; private void button9_Click(object sender, EventArgs e) &#123; addNum(9); &#125; private void button10_Click(object sender, EventArgs e) &#123; addNum(0); &#125; private void sum_Click(object sender, EventArgs e) &#123; if (textBox1.Text != &quot;&quot;) &#123; pos = 4; click(); ch = &quot;+&quot;; &#125; &#125; private void min_Click(object sender, EventArgs e) &#123; if (textBox1.Text != &quot;&quot;) &#123; pos = 3; click(); ch = &quot;-&quot;; &#125; &#125; private void cheng_Click(object sender, EventArgs e) &#123; if (textBox1.Text != &quot;&quot;) &#123; pos = 2; click(); ch = &quot;*&quot;; &#125; &#125; private void chu_Click(object sender, EventArgs e) &#123; if (textBox1.Text != &quot;&quot;) &#123; pos = 1; click(); ch = &quot;/&quot;; &#125; &#125; private void equal_Click(object sender, EventArgs e) &#123; calc(); &#125; private void clear_Click(object sender, EventArgs e) &#123; textBox1.Text = &quot;&quot;; temp1 = 0; pos = 0; index = 0; isresult = false; ch = &quot;&quot;; &#125; //用来处理等于计算 private void calc() &#123; float temp2 = Convert.ToSingle(textBox1.Text); switch (pos) &#123; case 1: textBox1.Text = (temp1 / temp2).ToString(); break; case 2: textBox1.Text = (temp1 * temp2).ToString(); break; case 3: textBox1.Text = (temp1 - temp2).ToString(); break; case 4: textBox1.Text = (temp1 + temp2).ToString(); break; &#125; isresult = true; index = 0; &#125; //用来处理连续计算 private void click() &#123; if (index == 0) &#123; temp1 = Convert.ToSingle(textBox1.Text); index++; textBox1.Text = &quot;&quot;; &#125; else &#123; selectCh(ch); textBox1.Text = temp1.ToString(); isresult = true; &#125; &#125; //根据传入符号进行连续计算 private void selectCh(string ch1) &#123; switch (ch1) &#123; case &quot;+&quot;: temp1 += Convert.ToSingle(textBox1.Text); break; case &quot;-&quot;: temp1 -= Convert.ToSingle(textBox1.Text); break; case &quot;*&quot;: temp1 *= Convert.ToSingle(textBox1.Text); break; case &quot;/&quot;: temp1 /= Convert.ToSingle(textBox1.Text); break; &#125; &#125; &#125;&#125; 运行效果1.使用等号计算 2.连续计算]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D开发(一)]]></title>
    <url>%2F2017%2F09%2F09%2FUnity3D%E5%BC%80%E5%8F%91%2FUnity3D%E5%BC%80%E5%8F%91-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Unity5.6烘焙功能及post插件 烘焙系统 在一个场景中，由于灯光组件起到实时渲染的效果，并直接与计算机硬件GPU渲染器进行交互作用，因此对计算机显卡性能不良，以至于计算机出现渲染卡帧等现象，为了提高计算机性能，对应用，游戏应当进行优化处理，灯光烘焙即是优化计算机性能的一种方式，灯光烘焙将灯光由光电热资源转换成灯光光照贴图从而优化场景 优点: 用空间换时间,静态生成光照贴图(LightMap)，减小GPU和显卡的负担,使用于静止不动的物体 在程序运行之前就能预览光照效果，与实时光照系统不同的是，不会出现预料之外的情况 烘焙操作 打开 Window -&gt; Lighting -&gt; Setting 并将设置功能框移动到选项卡上方便之后的操作 关闭 Realtime Golbal Ilumina Compress Lightmaps 打开 Ambient Occlusion 并关闭Auto Generate 设置如图 Lightmapper 选择5.6新的Progressive(渐进式渲染)模式 将场景中的物体设置为Static(只有设置为Static的物体才会被烘焙)，并将场景中的光源设置为Mixed模式(动静混合) 在保存当前场景后点击Generate Lighting 生成光照贴图 烘焙之前的物体曝光过度 烘焙过后的物体过度自然 增加一个动态Cube,阴影细节比烘焙的效果差很多 Tips: 不知道是不是新版本的Bug，再Mixed模式下的灯光下勾选了Static的物体应该不会再接受动态阴影，只能在生成贴图后再将物体的Cast Shadows关掉，手动关闭动态阴影(用户体验极差 -。-) post插件这是一个为摄像机添加后期特效的插件，可以实现3A级游戏的画面体验 如何获取在Unity的资源商店中搜索post下载并导入工程 使用方式 导入Unity的Character资源包选择Fps控制器，为它的摄像机添加 Post Processing Behaviour 组件 在 Project 面板中右键创建一个 Post-Processing Profile 并将它拖给 Post Processing Behaviour 组件 双击 Post-Processing Profile 进行属性的设置 重要属性 Antialiasing(抗锯齿)：此选项要生效必须先将引擎内置的抗锯齿关掉 Ambient Occlusion(环境光遮蔽)：描绘物体和物体相交或靠近的时候遮挡周围漫反射光线的效果，可以解决或改善漏光、飘和阴影不实等问题，解决或改善场景中缝隙、褶皱与墙角、角线以及细小物体等的表现不清晰问题，综合改善细节尤其是暗部阴影，增强空间的层次感、真实感，同时加强和改善画面明暗对比，增强画面的艺术性。 Depth of field：模拟视距对画面的影响 Motion Blur(运动模糊)： 没有采用运动模糊的计算机动画，当物体快速移动时，缺乏连贯性和真实感。添加了运动模糊特效后使运动变得更平滑，场景更逼真。 Bloom(泛光)：适当的调整能使画面增强真实感。当光照对比差异悬殊的情况下，明亮的部分会显得像在发光，这种现象在电影和摄影的时候是很常见的。泛光是一种增强版的辉光和耀斑的效果。 Color Grading：实现了行业水平的颜色分级游戏中色彩模仿和调整，如Photoshop的颜色变换，如改变对比度，色彩曲线，曝光，饱和度，色调等。 Demo]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理初探(五)]]></title>
    <url>%2F2017%2F08%2F27%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[正则表达式 定义 对给定的字符集∑={c1 , c2 , … , cn} 归纳定义: 空串∑是正则表达式 对于任意c∈∑，c是正则表达式 如果M和N是正则表达式，则以下也是正则表达式 选择 M|N = {M,N} 连接 MN = {mn| m∈M , n∈N} 闭包 M* = {∑,M,MM,MMM,…} 对于给定的字符集∑={a,b},可以写出哪些正则表达式? {a,b} (空串∑是正则表达式) {a},{b} (对于任意c∈∑，c是正则表达式) {a,a},{b,b},{a,∑},{b,∑},{∑,∑} (选择) {∑a},{∑,b},{∑∑},{ab},…,{a(∑|a)} (连接) ∑，…, a(∑|a) (闭包) 关键字表示正则表达式可以用来表示语法中的关键字 如 if其中 i∈∑ 又 f∈∑根据连接 if∈∑ 标识符表示C语言中的标识符：以字母或下划线开头，后跟零个或多个字母、数字或下划线可以用正则表达式表示： （a|b|c|…|z|A|B|C|…|Z|_ ) (以字母或下划线开头) （a|b|c|…|z|A|B|C|…|Z|_|0|1|2|…|9 )* (后跟零个或多个字母、数字或下划线) 语法糖 可以引入语法糖来简化正则表达式 [c1-cn] == c1|c2|…|cn e+ == 一个或多个e e? == 零个或一个e “a“ == a自身，不是a的Kleen闭包 e{i,j} == i到j个e的连接 · == 除’\n’外的任意字符]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理初探(四)]]></title>
    <url>%2F2017%2F08%2F26%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[词法分析器的简单实现方法 词法分析器的构造方法 1.手工编码实现方法 相对复杂、且容易出错 但是目前非常流行的实现方法 2.词法分析器的生成器 可快速原型、代码量较少 但较难控制细节 手工编码转移图 判断”&gt;” , “&lt;” , “&gt;=” , “&lt;=” , “=” 及 “&lt;&gt;”(不等于)的逻辑转移图 如果第一个字符为 “&lt;” 或 “&gt;”则需要读取第二个字符来判断返回值 图中的 “星号” 代表读取到的字符为”&lt;” , “&gt;” , “=”之外的其他字符，需要进行回滚(rollback)操作 伪代码表示方法：12345678910111213141516171819202122//定义一个函数返回值为 token 即记号流的数据结构token nextToken()//读取第一个字符c = getChar();//分支判断switch (c) case &apos;&lt;&apos; ： //读取第二个字符 c = getChar(); switch(c) case &apos;&gt;&apos;：return NE; case &apos;=&apos;：return LE; //否则进行回滚操作 default：rollback(); return LT; case &apos;=&apos; ： return EQ; case &apos;&gt;&apos; ： /读取第二个字符 c = getChar(); switch(c) case &apos;=&apos;：return GE; //否则进行回滚操作 default：rollback(); return GT; 回滚操作的实现回滚操作要求将文件流或者数组索引向前移动一个字符，因此有两种方法进行回滚操作 文件流回滚对文件的操作在C中需要一个函数头文件：1#include &lt;stdio.h&gt; 定义函数：123456789101112int fseek(FILE * stream, long offset, int whence);stream： 你打开文件的索引offset：偏移量whence：offset基于此参数进行移动，此参数有3个值SEEK_SET 从距文件开头offset 位移量为新的读写位置. SEEK_CUR 以目前的读写位置往后增加offset 个位移量.SEEK_END 将读写位置指向文件尾后再增加offset 个位移量. 当whence 值为SEEK_CUR 或SEEK_END 时, 参数offset 允许负值的出现. 因此实现代码如下123456int rollback()&#123; int result; result = fseek(*file , -1 , SEEK_CUR); return result;&#125; 优缺点 优点：不需要维护数组，节省内存缺点：直接操作源文件不安全且直接从文件中读字符速度较慢 数组回滚维护一个数组，将源文件读入数组中，直接对数组指针进行操作 123456void rollback()&#123; //检测数组是否越界 if(_filePositon&gt;0) _filePositon --；&#125; 优缺点 优点：直接操作数组，效率高缺点：当源文件较大时，需要占用较大的内存空间]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理初探(三)]]></title>
    <url>%2F2017%2F08%2F25%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[词法分析 词法分析原理将源程序看做是字符流并进行切割划分，每一个部分就叫做记号或单词 源程序：1234if (x &gt; 5) y = &quot;hello&quot;;else z = 1; 转换成记号：1234IF LPAREN IDENT(x) GT INT(5) RPAREN IDENT(y) ASSING STRING(&quot;hello&quot;) SEMICOLONELSE IDENT(z) ASSING INT(1) SEMICOLON EOF(结束标志) 记号数据结构12345enum kind &#123;IF , LPAREN , IDENT , INTLIT , ...&#125;;//词法分析器所能识别的所有记号的分类struct token&#123; enum kind k; char * lexeme; //单词&#125;; 源程序在转换成记号前就会得到相应的结构体token 比如 if(x &gt; 5) 得到以下 token token{k = IF , lexeme = 0}; token{k = LPAREN , lexeme = 0}; token{k = IDENT , lexeme = “x”}; token{k = GT , lexeme = 0}; token{k = INT , lexeme = 5}; token{k = RPAREN, lexeme = 0}; token{k = EOF, lexeme = 0}; 小结词法分析器的任务：字符流到记号流 字符流：和被编译的语言密切相关 （ASCII , Unicode等） 记号流： 编译器内部定义的数据结构，编码所识别出的词法单元]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理初探(二)]]></title>
    <url>%2F2017%2F08%2F23%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[编译器结构 编译器的高层结构 编译器可以看成多个阶段构成的”流水线”结构 词法分析：将字符序列转化为对应的记号序列 语法分析：对语法的正确性进行判断 词义分析：判断抽象语法树的真确性，如果无误，则表明源代码没有语法上的错误 代码生成：将中间代码转换成可执行的目标代码 符号表：对各个阶段提供支持]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理初探(一)]]></title>
    <url>%2F2017%2F08%2F22%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[编译器溯源 什么是编译器 计算设备如个人计算机，大型机，嵌入式系统及智能设备其核心是软件 软件由高级语言编写而成，编译器就是将各式各样的高级语言转换成对应硬件平台可执行指令的处理程序 核心功能是将源代码翻译成目标代码 · 源代码 · c/c++ , java , SQL , html 等高级语言 · 目标代码 · x86 , IA46 , ARM , MIPS 等架构的机器指令 编译器产生的目标代码与源代码语意相同但不执行，是静态计算 解释器是与编译器类似的处理程序，它将源代码按行翻译成目标代码并执行，速度较慢是动态计算 编译器简史 历史上第一个编译器是Fortran语言的编译器，它在多个方面产生了深远的影响 · 理论上 : 形式语言，自动机技术，文法，语法指导的翻译· 实践上：算法，数据结构· 编译器架构：后世的架构大多受此编译器架构的影响 为什么学习编译器设计 编译原理集中体现了计算机科学的很多核心思想，是深入学习算法与数据结构的助力 编译器是其他领域的重要研究基础 编译器本身就是非常重要的研究领域，是大型软件构造和维护的重要手段]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D进阶(终)]]></title>
    <url>%2F2017%2F08%2F14%2FUnity3D%E8%BF%9B%E9%98%B6%2FUnity3D%E8%BF%9B%E9%98%B6-%E7%BB%88%2F</url>
    <content type="text"><![CDATA[模拟重力及镜头旋转 模拟重力使用角色控制器额的Move方法123456789101112131415161718private CharacterController cc;//定义角色y轴上的位移量private float vy=0;//定义重力public grivity=-9.8f//获取当前物体的任务控制器组件cc=getCompent&lt;CharacterController&gt;();//人物控制器的只读变量 IsGrounded可以判断当前控制器组件是否与地面接触if(!cc.IsGrounded) //位移量受重力影响而减小 vy-=grivity;if(cc.IsGrounded &amp;&amp; Input.getkeydown(KeyCode.Space))&#123; //模拟跳跃 vy=5; &#125;cc.Move(transform.transformDirection(0,vy*Time.delateTime,0)); 使用这种方法模拟重力，可以实现跳跃时，减速上升–&gt;相对静止–&gt;加速下降直至落地的效果 镜头控制Fps游戏中镜头的转动，一般是通过改变摄像机的欧拉角来实现的 对于在三维空间里的一个参考系，任何坐标系的取向，都可以用三个欧拉角来表现。参考系又称为实验室参考系，是静止不动的。而坐标系则固定于刚体，随着刚体的旋转而旋转。 亦即是说在Unity中我们可以使用一个三维向量 Vector3(x,y,z)来表示一个transform组件的欧拉角 123456789101112//获取鼠标在水平和竖直方向上的位移float vx=Input.getAxis(&quot;Mouse X&quot;);float vy=Input.getAxis(&quot;Mouse Y&quot;);//获取摄像机的引用Camera c=Camera.main;//获取当前摄像机的欧拉角Vector3 temp=c.transform.eulerAngles;//应用位移量temp.x+=vx;temp.y+=vy;//改变摄像机的欧拉角c.transform.eulerAngles=temp; 推荐将以上方法应用在Update中实现流畅的镜头移动 结语暑假将尽，暂时停止Unity系列的更新~~~~ （。-。）]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D进阶(七)]]></title>
    <url>%2F2017%2F08%2F13%2FUnity3D%E8%BF%9B%E9%98%B6%2FUnity3D%E8%BF%9B%E9%98%B6-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[人物控制器的Move方法及Transform.transformDirection()方法 CharacterController.Move1234567891011121314private CharacterController cc;//获取当前组件的人物控制器cc=gameObject.getCompenent&lt;CharacterController&gt;();void Update()&#123; //获取水平方向上的变化值 int x=Input.getAxis(&quot;Horizontal;&quot;); //或取垂直方向上的变化值 int y=Input.getAxis(&quot;vertical&quot;); //使用move方法进行移动 cc.Move(new Vector3(x*speed,0,y*speed));&#125; Transform.transformDirection如果你使用上面的方法进行人物的移动，你会发现控制的物体发生旋转后，移动的方向是基于世界坐标系的，如果你想让物体按照自身的坐标系进行移动，你需要这个新的方法1234//使用transformDirection方法将给定的世界坐标转换成自身的坐标cc.Move(cc.transform.transformDirection(new Vector3(x*speed,0,y*speed)));//这个方法还可以获取指定transform组件的某个方向transform.transformDirection(new Vector3(1,0,0))； 简单来说: 给定一个基于自身的向量Vector3（比如说我要向我的右边走） 把这个向量转换成世界的向量（方法将右边这个概念转换成世界坐标系中的明确方向） 向转换后的世界方向进行移动]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D进阶(六)]]></title>
    <url>%2F2017%2F08%2F10%2FUnity3D%E8%BF%9B%E9%98%B6%2FUnity3D%E8%BF%9B%E9%98%B6-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[Unity Ragdoll系统 RagdollRagdoll又被称为布娃娃系统，在游戏中常被用来模拟逼真的死亡效果 Ragdoll创建 将你的人物模型放入 Hierarchy 面板中 在5.6的版本中Ragdoll被放在了 GameObject 的3D Object 中 点击打开 你需要为Ragdoll绑定所有的骨骼节点 设置完成在场景中添加一个地面，点击播放按钮就可以看到效果了 实际应用在游戏中用来模拟死亡的效果，有两种实现方法 一其一是将Ragdoll绑定在带有动画的模型上，在其”死亡”时，关闭Animator组件，转化到Ragdoll模式 很不幸的是，动画变得十分鬼畜，移除动画组件后虽然效果尚可，但是动画的播放成了硬伤 接下来试试把模型下的所有绑定了 Ragdoll 的关节的刚体属性设置为 IsKinematic(即不受物理因素影响) Bingo! 成果显著，使用这种方法应用死亡效果，需要遍历模型下所有的刚体属性并把 IsKinematic 设置为 false 话不多说上代码 12345678910111213141516171819202122232425262728293031323334353637383940using UnityEngine;public class control : MonoBehaviour &#123; //人物的模型 public GameObject theModel; //管理人物的父物体即绑定了动画组件的物体 public GameObject cc; public Rigidbody r; void Update () &#123; if (Input.GetKeyDown(KeyCode.Z)) &#123; //关闭动画 cc.GetComponent&lt;Animator&gt;().enabled = false; theModel.GetComponent&lt;Rigidbody&gt;().isKinematic = false; //以当前的Transform组件为入口 setKinematic(gameObject.transform); &#125; &#125; //遍历所有子节点 void setKinematic(Transform Father) &#123; foreach (Transform child in Father) &#123; r = child.gameObject.GetComponent&lt;Rigidbody&gt;(); if (r != null) &#123; r.isKinematic = false; &#125; //以当前节点为父节点向下遍历 setKinematic(child); &#125; &#125;&#125; 二其二使用官方教程中的一种方法，准备一个播放动画模型的预制体，为这个预制体添加Ragdoll在角色死亡时用这个预制体来进行替换，不说了上代码 1234567891011121314151617181920212223242526272829303132333435363738using UnityEngine;public class test : MonoBehaviour &#123; public GameObject theCopy; // Use this for initialization void Start () &#123; &#125; void Update () &#123; if (Input.GetKeyDown(KeyCode.Z)) &#123; //销毁原来的模型 Destroy(gameObject); //在原地生成布娃娃 GameObject g = Instantiate(theCopy, transform.position, transform.rotation); CopyTransformsRecurse(transform,g.transform); &#125; &#125; //从原来的模型将所有的位置及旋转信息复制到预制体上 void CopyTransformsRecurse(Transform src, Transform dst) &#123; dst.position = src.position; dst.rotation = src.rotation; foreach (Transform child in dst) &#123; // Match the transform with the same name Transform curSrc = src.Find(child.name); if (curSrc) CopyTransformsRecurse(curSrc, child); &#125; &#125;&#125; 总结如果你需要在角色倒地后站立起来继续游戏，你不妨试试第一种方法，如果你单纯的想模拟死亡效果可以用第二种方法，因为第二种方法要消除原来的物体所以不能模拟前面的情景，今天到此为止我要吃饭了（&gt;-&lt;）]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D进阶(五)]]></title>
    <url>%2F2017%2F08%2F08%2FUnity3D%E8%BF%9B%E9%98%B6%2FUnity3D%E8%BF%9B%E9%98%B6-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[NGUI的自适应屏幕 和 Input.GetAxis()方法 NGUI自适应屏幕新版的NGUI在 UIRoot的Scalling style(缩放样式)中加入了 Constrained属性只要设置其下的 Content Width和Content Height 为Game视窗的大小，并勾选其后的 fit，UI就可以适应任何大小的屏幕 GetAxis1Input.GetAxis(String); 获取任意轴上的方向并返回一个(-1,1)之间的 floatU3D定义了一些轴,你也可以自己定义 这个返回的值类似于插值计算，所以可以用来模拟人物移动速度从慢到快的效果 12345float v = Input.GetAxis(&quot;Verticalplayer1&quot;);rigi.velocity = transform.forward * v * speed;float h = Input.GetAxis(&quot;Horizontalplayer1&quot;);rigi.angularVelocity = transform.up * h * angularSpeed;]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D进阶(四)]]></title>
    <url>%2F2017%2F08%2F07%2FUnity3D%E8%BF%9B%E9%98%B6%2FUnity3D%E8%BF%9B%E9%98%B6-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[UI Button的创建及事件管理 和 UI的动态加载 UI ButtonUI最主要的任务就是展示数据与用户交互，因此可以用来交互的按钮是必不可少的 Button 创建Button的创建是在Label 或Sprite上添加相应组件实现的 选中一个Sprite图片右键 Attach -&gt; Box Collider 添加碰撞体，添加的碰撞体会自动适应图片的大小 继续在图片上右键 Attach -&gt; UI Button 添加按钮组件 UI Button 面板属性 Colors: 可以选择按钮在不同的四种状态下的颜色变化 (normal，hover，pressed，disabled) Sprites: 与Colors类似可以选择要替换的图片 On Click: 可以拖拽指定的脚本，并选择指定的方法进行响应，但不推荐用这个方法 UI Button 点击事件管理 UI Button 自带的On Click: 将脚本绑定在对应的按钮上，并将此脚本拖拽到On Click中的Notify区域实现事件绑定，操作过于繁琐且不易于统一的管理 使用事件委托 OnClick方法，为按钮绑定相应的脚本，一个按钮对应一个脚本，同样不利于管理 为每一个按钮添加 UI Event Listener 组件，在UI Root下创建一个脚本 使用以下方法，就可以在一个脚本中管理所有的按钮事件 12345678910111213141516171819202122232425262728using UnityEngine;public class clickmanager : MonoBehaviour &#123; void Awake() &#123; //获取按钮对象 GameObject button = GameObject.Find(&quot;button&quot;); //将该按钮的 UIEventListener的onClick方法指向到本地类中的自定义方法 UIEventListener.Get(button).onClick = OnButtonclick; GameObject button2 = GameObject.Find(&quot;button2&quot;); UIEventListener.Get(button2).onClick = OnButton2click; &#125; //自定义方法，要注意必须带有一个GameObject参数与onClik委托进行匹配 private void OnButtonclick(GameObject button) &#123; Debug.Log(1); &#125; private void OnButton2click(GameObject button) &#123; Debug.Log(2); &#125;&#125; UI 动态加载在UI制作完成后通常将UI Root下的子元素制作为预制体，在场景中动态加载 加载方法123456789101112131415using UnityEngine;public class uimanager : MonoBehaviour &#123; private GameObject prefab_info; void Start () &#123; //将资源文件夹中的UI加载进内存，并保存引用 prefab_info=Resources.Load&lt;GameObject&gt;(&quot;info&quot;); //使用NGUITools的AddChild方法为当前UI Root 添加子物体 NGUITools.AddChild(gameObject,prefab_info); &#125; &#125; 启动之后动态的加载了UI]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D进阶(三)]]></title>
    <url>%2F2017%2F08%2F06%2FUnity3D%E8%BF%9B%E9%98%B6%2FUnity3D%E8%BF%9B%E9%98%B6-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[(Atlas maker)图集制作 及 UI Sprite显示图片 图集图集是图片的一种压缩格式在NGUI中使用图集为单位进行图片的保存与管理 Atlas makerNGUI自带的图集制作工具 使用方法 NGUI菜单 -&gt;open -&gt; Atlas maker 在打开的界面中选择右上角的new按钮新建图集 将想要打包成图集的图片拖进Project面板，点选图片资源后进行打包 图集的管理随着项目的进行可能需要对图集中的资源进行修改，这时少不了对图集的修改和更新操作 Tip: 打包的图片不能存在重名 UI Sprite在NGUI中负责图片的显示 属性面板 Atlas 指定图集 Sprite 指定图集中的某张图片 Type 图片的显示方式 (1)simple (2)Sliced 分割模式 用于解决图片放大失真的问题 (3)Tiled 平铺模式 图片随着size区域的大小而变化，如果区域过大则会显示多张，过小则显示不完整 (4)Filled 填充模式 可以用来制作技能cd效果，或者是切换动画 depth 深度 深度越高图片的渲染优先级越高 ，即深度高的图片会覆盖深度低的图片 代码控制Sprite创建该脚本绑定在 UI Root上 1234567891011121314151617181920212223 using UnityEngine;public class CodeContCreat : MonoBehaviour &#123; void Start () &#123; //获取UIRoot的transform组件 Transform t = gameObject.GetComponent&lt;Transform&gt;(); //创建一个名为CodeControl的空对象 GameObject UISprite = new GameObject(&quot;CodeControl&quot;); //设置空物体的父对象为UIRoot UISprite.GetComponent&lt;Transform&gt;().SetParent(t); //重置空物体Scale属性 重置一定要放在设置父对象之后，否则重置效果会被覆盖 UISprite.GetComponent&lt;Transform&gt;().localScale = Vector3.one; //加载图集 UIAtlas atlas = Resources.Load&lt;UIAtlas&gt;(&quot;UI Atlas&quot;); //为空对象赋予UI Sprite组件并获取 UISprite Sprite=UISprite.AddComponent&lt;UISprite&gt;(); //指定图集 Sprite.atlas = atlas; //指定图片 Sprite.spriteName = &quot;bg&quot;; &#125;&#125; 代码添加图片的效果]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D进阶(二)]]></title>
    <url>%2F2017%2F08%2F05%2FUnity3D%E8%BF%9B%E9%98%B6%2FUnity3D%E8%BF%9B%E9%98%B6-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[NGUI简单介绍及 UI Lable面板参数详解 NGUINGUI是Unity最火的第三方UI插件 插件安装将插件包直接导入到 unity 的project面板中点击下载NGUI V3.10.0 版本导入完成后菜单栏中就会多出一项NGUI，至此插件安装完成 NGUI目录结构 Editor: 外部扩展编辑器 Examples: 官方制作的一些场景示例 Resources: 资源文件 Scripts: 存放脚本文件 官方示例在 文件夹 NGUI -&gt; Examples -&gt; Scenes 中存放着相关案例2D界面 3D界面 Ul Lable作用在NGUI中负责文字部分的显示 Tips: 为了调试方便通常在2D模式下进行UI界面的编写 常用属性 Font: 字体 在NGUI中的字体格式为字体图集，即将需要用到的字压缩成图片的形式，但是这种方式并不适合中文等一些字比较多的语言，因此要想让 Lable显示中文需要切换到 Unity 使用 TTF字体文件 Font Size: 字体大小 后面的下拉选框可以选择文字的加粗与倾斜效果 Material: 字体材质 赋予材质球来美化字体显示 Text: 要显示的内容 Modifier: 适用于英文 可以选择Text中的内容是以小写还是大写显示 Overflow: 选择在文字超出给定区域情况下的处理方案 (1) shrink Content 自动缩小内容以保证所有文字显示在给定区域中(2)clamp Content 显示给定区域中的文字，超出的不显示(3)Resize Freely 自由扩展区域以适应文字(4)Resize Height 仅扩展高度不扩展宽度 Alignment 选择对齐方式 Gradient 文字颜色渐变显示 (1)Top 起始颜色 (2)Bottom 结束颜色 Effect 设置文字特效 (1)Shadow 文字阴影(2)Outline 文字外边框 另外后面的颜色选择器可以自行调整特效颜色 Color Tint 文字色彩 一般设置为白色不影响Gradient 的渐变效果，在不需要使用渐变的情况下使用该属性设置纯色]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D进阶(一)]]></title>
    <url>%2F2017%2F08%2F02%2FUnity3D%E8%BF%9B%E9%98%B6%2FUnity3D%E8%BF%9B%E9%98%B6-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Camera.ScreenToWorldPoint() API个人理解 和 RTS游戏点击移动的实现思路 ScreenToWorldPoint官方定义 public Vector3 ScreenToWorldPoint(Vector3 position);DescriptionTransforms position from screen space into world space.Screenspace is defined in pixels. The bottom-left of the? screen is (0,0); the right-top is (pixelWidth,pixelHeight). The z position is in world units from the camera. 大体意思就是将一个变换组件的位置从屏幕坐标转化为世界坐标(单位是像素)，屏幕的左下方是原点 (0,0),右上方的坐标为(width,height)单位为像素，z轴表示的是该位置到摄像机的距离 实际测试这个API在使用时需要对Input.MousePosition加上一个z轴坐标才会有效，因为MousePosition返回的三维向量z轴值为0 123456789101112131415161718192021222324252627using System.Collections;using System.Collections.Generic;using UnityEngine;public class test : MonoBehaviour &#123; private Camera m_camera; //引入的预制体 public GameObject g; void Start () &#123; //获取主摄像机的引用 m_camera = Camera.main; &#125; void Update () &#123; if (Input.GetMouseButtonDown(0)) &#123; //获取预制体的变换组件并改变位置为鼠标点击位置转化后的世界坐标 g.GetComponent&lt;Transform&gt;().position= m_camera.ScreenToWorldPoint(Input.mousePosition + new Vector3(0, 0, 10)); //在变化后的位置生成一个预制体 Instantiate(g, m_camera.ScreenToWorldPoint(Input.mousePosition + new Vector3(0, 0, 5)), Quaternion.identity); &#125; &#125;&#125; z轴赋值为5 z轴赋值为50 总结 在使用时需要加上一个 Vector3(0,0,z)否则转换后获取的坐标就是摄像机所在的位置 z的值越大，获取的坐标离摄像机越远，x和y的值变化幅度也越大 TPS游戏人物点击移动构想 起初想用ScreenToWorldPoint方法实现这一功能，但是实际发现这个方法并不能满足需求，因为这个方法返回的位置y轴始终是变化的，而游戏要求人物应该是贴着地面走 使用射线的碰撞的方法可以完成这一需求，射线碰撞返回碰撞的位置，给人物的Transfrom.position赋值这个位置即可 实现123456789101112131415161718192021222324252627282930313233343536373839404142using System.Collections;using System.Collections.Generic;using UnityEngine;public class RAY : MonoBehaviour &#123; private Camera m_camera; //用来存储碰撞物体的信息 private RaycastHit hit; //定义射线存储ScreenPointToRay返回的值 private Ray ray; public GameObject g; void Start () &#123; //获取主摄像机的引用 m_camera = Camera.main; &#125; void Update () &#123; if (Input.GetMouseButtonDown(0)) &#123; //获取目标物体的实际y轴长度 float y=g.GetComponent&lt;MeshFilter&gt;().mesh.bounds.size.y*g.transform.localScale.y; ////将当前鼠标点击的位置作为终点产生一条射线 ray = m_camera.ScreenPointToRay(Input.mousePosition); ////Physics.Raycast(Ray,out RaycastHit) RaycastHit存储与射线发生碰撞物体的信息 if (Physics.Raycast(ray, out hit)) &#123; //销毁碰撞物体 //Destroy(hit.collider.gameObject); Debug.Log(hit.collider.name); //如果点击自己不改变位置，否则就会越来越高 if (hit.collider.gameObject.name != &quot;Cube&quot;) &#123; g.GetComponent&lt;Transform&gt;().position = hit.point + new Vector3(0, y / 2, 0); //加上高度的一半,使物体始终处于地面上部 &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
        <tag>-进阶知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TPS射击游戏实战开发(终)]]></title>
    <url>%2F2017%2F07%2F31%2FTPS%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%2FTPS%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91-%E7%BB%88%2F</url>
    <content type="text"><![CDATA[最终实现:人物控制及子弹发射 U3D自带角色控制器Assest -&gt; Import Package -&gt; Characters可以导入U3D自带的人物控制器 人物移动及镜头移动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123using UnityEngine;public class CameraMove : MonoBehaviour &#123; void Start() &#123; mMoveSpeed = 5f; isAiming = false; cc = GetComponent&lt;CharacterController&gt;(); &#125; void Update() &#123; UpdateLookAt(); //放大镜头 if (Input.GetMouseButtonDown(1)) &#123; if (isAiming) &#123; ACamera.depth = -2; isAiming = false; &#125; else &#123; ACamera.depth = 0; isAiming = true; &#125; &#125; &#125; void FixedUpdate() &#123; UpdateMovement(); &#125; // 第一人称控制器的常量与变量 public Transform SCamera; public Camera ACamera; public GameObject hero; private CharacterController cc; private bool isAiming; public float mMoveSpeed; // 物体移动速度 public float mMouseSensitivity = 10; // 鼠标旋转的敏感度 public float mMinimumX = -25; // 向下望的最大角度 public float mMaximumX = 45; // 向上望的最大角度 public float mMinimumY = -360; // 向左望的最大角度 public float mMaximumY = 360; // 向右望的最大角度 private Vector3 _curRotation = new Vector3(0, 0, 0); // 当前旋转角度 // 更新移动位置 private void UpdateMovement() &#123; float distance = mMoveSpeed * Time.deltaTime; // 移动距离 if (Input.GetKey(KeyCode.Escape)) &#123; this.enabled = false; &#125; if (Input.GetKey(KeyCode.W)) &#123; cc.Move(transform.forward * distance); &#125; if (Input.GetKey(KeyCode.S)) &#123; cc.Move(transform.forward* -1 * distance); &#125; if (Input.GetKey(KeyCode.A)) &#123; cc.Move(transform.right* -1 * distance); &#125; if (Input.GetKey(KeyCode.D)) &#123; cc.Move(transform.right * distance); &#125; &#125; // 更新摄像头指向位置 private void UpdateLookAt() &#123; // 左右旋转 _curRotation.y = _curRotation.y + Input.GetAxis(&quot;Mouse X&quot;) * mMouseSensitivity; _curRotation.y = Mathf.Clamp(_curRotation.y, mMinimumY, mMaximumY); // 上下旋转 _curRotation.x = _curRotation.x - Input.GetAxis(&quot;Mouse Y&quot;) * mMouseSensitivity; _curRotation.x = Mathf.Clamp(_curRotation.x, -mMinimumX, mMaximumX); if (_curRotation.x &lt;= -65f) &#123; _curRotation.x = -65f; &#125; // 设置摄像头 Vector3 rotation = transform.eulerAngles; SCamera.localEulerAngles = new Vector3(_curRotation.x, SCamera.rotation.y, SCamera.rotation.z); rotation.y = _curRotation.y; transform.eulerAngles = rotation; &#125; //更改速度方法 public void setSpeed(float speed) &#123; mMoveSpeed = speed; &#125;&#125; 子弹射线 使用预备课中讲过的射线方法实现子弹发射 使用SendMessage这个强大的方法来实现物体Hp的减少123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293using UnityEngine;public class FireControl : MonoBehaviour &#123; public GameObject bullet; public GameObject anim; private Animator a; private LineRenderer m_line; public Transform look; public Ray myRay; RaycastHit myHit; bool canFire = true; //射速 int shoot_speed=0; //弹药 int ammo = 30; void Start() &#123; m_line = gameObject.GetComponent&lt;LineRenderer&gt;(); a = anim.GetComponent&lt;Animator&gt;(); &#125; void Update() &#123; if (Input.GetKeyDown(KeyCode.Q)) &#123; if (m_line.enabled) &#123; m_line.enabled = false; &#125; else m_line.enabled = true; &#125; m_line.SetPosition(0,transform.position); m_line.SetPosition(1, transform.position+transform.forward); &#125; void FixedUpdate() &#123; if (Input.GetKeyDown(KeyCode.R)) &#123; if (ammo &lt;= 29) &#123; canFire = false; a.SetBool(&quot;Reloding&quot;, true); ammo = 30; Invoke(&quot;FireAgain&quot;,2.5f); &#125; &#125; if(canFire) if (Input.GetMouseButtonDown(0)) &#123; if (ammo &gt; 0) &#123; ammo--; //Instantiate(bullet, new Vector3(transform.position.x, transform.position.y, transform.position.z), Quaternion.identity); myRay = Camera.main.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(myRay, out myHit)) &#123; Debug.Log(myHit.collider.gameObject.name); myHit.collider.gameObject.SendMessage(&quot;reduce&quot;); &#125; shoot_speed = 0; &#125; &#125; if(canFire) if (Input.GetMouseButton(0)) &#123; shoot_speed++; if (shoot_speed == 7 &amp;&amp; ammo&gt;0) &#123; ammo--; //Instantiate(bullet, new Vector3(transform.position.x, transform.position.y, transform.position.z), Quaternion.identity); myRay = Camera.main.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(myRay, out myHit)) &#123; Debug.Log(myHit.collider.gameObject.name); myHit.collider.gameObject.SendMessage(&quot;reduce&quot;); &#125; shoot_speed = 0; &#125; &#125; &#125; void FireAgain() &#123; canFire = true; a.SetBool(&quot;Reloding&quot;, false); &#125;&#125; 结语说是实战，其实还是个小Demo (^__^) 嘻嘻……）]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TPS射击游戏实战开发(二)]]></title>
    <url>%2F2017%2F07%2F31%2FTPS%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%2FTPS%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Mecanim动画系统介绍 前言为了让游戏更加真实，有时需要角色拥有丰富的角色动作，U3D的动画系统可以让我们方便进行动画的播放和管理 AnimatorU3D 5 新加入的动画组件 属性 Controller: 自己定义的 Animator Controller组件，用来控制动画的播放的主要功能组件 Avatar: 人物模型 Apply Root Motion: 在Unity3D动画中，模型的位置、角度经常会发生变化，我们需要决定是否将模型在动画中发生的这些变换化用到实际模型（GameObject）中。我们将这个选项的√去除，防止动画产生位置影响 Update Mode：更新模式：Normal表示使用Update进行更新，Animate Physics表示使用FixUpdate进行更新（一般用在和物体有交互的情况下），Unscale Time表示无视timeScale进行更新（一般用在UI动画中）。 Culling Mode：剔除模式：Always Animate表示即使摄像机看不见也要进行动画播放的更新，Cull Update Transform表示摄像机看不见时停止动画播放但是位置会继续更新，Cull Completely表示摄像机看不见时停止动画的所有更新。 使用动画系统导入人物模型这里提供我使用的资源包 直接将 你的人物.fbx 文件拖入Project面板 点击导入的模型，将模型设置为人形 将人物模型拖入Hierarchy面板为模型对象添加 Animator 在project 空白区域右击 Creat -&gt; Animator Controller 为创建的人物object添加组件 Animator 并绑定上一步创建的控制器 双击控制器 状态机 概念 状态机是用来管理动画的基本单位 一个初始的控制器有着以上三个基本状态 Entry: 初始状态 Any State: 任何状态 Exit: 退出 创建第一个动画 右击空白处 Creat State -&gt; Empty 创建一个新的状态机 这是我们会看到 从 Entry有一条线连接到了新创建的状态机上，这意味着控制器一进入就会播放 这个状态机的动画 导入动画文件，与人物的导入方法一样，直接拖入Project ，新建一个Animations 文件夹专门用来存放 动画文件 双击新状态机 在检视面板可以看到 Motion一项为 None,拖入或者点击右边的圆点来导入一个动画文件 同样动画文件也需要设置为人形，并且设置为循环播放，将动画的模型更改为你的模型（在Animations文件夹中 Ctrl + A全选所有文件可以批量更改，如果不更改模型，U3D会自动用一个自带模型的骨骼来播放动画，就会显得不协调） 运行一下试试看 这鬼畜的动作（-。-） Blend Tree 混合树动画系统可以用参数来控制动画的播放，优点是可以平滑的切换动画 具体操作 右键 Creat State -&gt; From New Blend Tree 创建一个混合动画树 双击动画树，点击中间的根节点，把右侧的检视面板中的 Blend Type 设置为 2D simple Directional 接下来用操作演示 如何创建变量 在右侧的设置面板中用刚刚创建的两个变量设置坐标 点击右下角的 加号 -&gt;Add Motion Field 添加新的动画区，并绑定动画，设置相应的坐标 我设置的9个动画状态 来看看如何用代码控制动画的播放123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148using UnityEngine;public class SwatC : MonoBehaviour &#123; private Animator anim; //存储变化的插值 private float Lerp_x; private float Lerp_y; private bool isAction; public GameObject speed; void Start () &#123; //获取动画控制组件 anim = GetComponent&lt;Animator&gt;(); isAction = false; &#125; void FixedUpdate () &#123; if (Input.GetMouseButton(0)) &#123; if (!anim.GetBool(&quot;Shift&quot;)) &#123; anim.SetBool(&quot;Fire&quot;, true); &#125; else &#123; anim.SetBool(&quot;Shift&quot;, false); speed.SendMessage(&quot;setSpeed&quot;, 5f); &#125; &#125; else &#123; anim.SetBool(&quot;Fire&quot;, false); isAction = true; &#125; if (Input.GetKeyDown(KeyCode.LeftShift)) &#123; if (!anim.GetBool(&quot;Shift&quot;)) &#123; anim.SetBool(&quot;Shift&quot;, true); anim.SetBool(&quot;Ctrl&quot;, false); speed.SendMessage(&quot;setSpeed&quot;,10f); &#125; else &#123; anim.SetBool(&quot;Shift&quot;, false); speed.SendMessage(&quot;setSpeed&quot;, 5f); &#125; &#125; if (Input.GetKeyDown(KeyCode.LeftControl)) &#123; if (!anim.GetBool(&quot;Ctrl&quot;)) &#123; anim.SetBool(&quot;Ctrl&quot;, true); anim.SetBool(&quot;Shift&quot;, false); speed.SendMessage(&quot;setSpeed&quot;, 2f); &#125; else &#123; anim.SetBool(&quot;Ctrl&quot;, false); speed.SendMessage(&quot;setSpeed&quot;, 5f); &#125; &#125; if (Input.GetKey(KeyCode.W)) &#123; Lerp(0, 1); isAction = true; &#125; if (Input.GetKey(KeyCode.A)) &#123; Lerp(-1, 0); isAction = true; &#125; if (Input.GetKey(KeyCode.W)&amp;&amp; Input.GetKey(KeyCode.A)) &#123; Lerp(-1, 1); isAction = true; &#125; if (Input.GetKey(KeyCode.S)) &#123; Lerp(0, -1); isAction = true; &#125; if (Input.GetKey(KeyCode.S) &amp;&amp; Input.GetKey(KeyCode.A)) &#123; Lerp(-1, -1); isAction = true; &#125; if (Input.GetKey(KeyCode.D)) &#123; Lerp(1, 0); isAction = true; &#125; if (Input.GetKey(KeyCode.S) &amp;&amp; Input.GetKey(KeyCode.D)) &#123; Lerp(1, -1); isAction = true; &#125; if (Input.GetKey(KeyCode.W) &amp;&amp; Input.GetKey(KeyCode.D)) &#123; Lerp(1, 1); isAction = true; &#125; if (!Input.anyKey) &#123; isAction = false; Lerp(0, 0); SetBlendTree(); &#125; if (isAction) &#123; SetBlendTree(); &#125; &#125; //动画渐变插值计算 void Lerp(float target_x,float target_y) &#123; Lerp_x = Mathf.Lerp(Lerp_x,target_x,0.15f); Lerp_y = Mathf.Lerp(Lerp_y, target_y,0.15f); &#125; //设置混合动画 void SetBlendTree() &#123; anim.SetFloat(&quot;X&quot;, Lerp_x); anim.SetFloat(&quot;Y&quot;, Lerp_y); &#125;&#125; 主要方法12345678Animator anim;//获取动画组件anim=getCompent&lt;Animator&gt;();//使用 set方法控制 自己定义的变量的值anim.setBool(&quot;你定义的变量的名称&quot;,true/false)anim.setFloat(&quot;你定义的变量的名称&quot;,value)通过控制变量的变化来切换动画还有其他几种方法 大家可以自己试试 将这个脚本绑定在人物模型上就可以控制角色前后左右移动以及奔跑下蹲了插值计算主要是用来进行动画的过渡平滑 我的三个混合树，（混合树之间的连线，可以右击树 Make Transition 并定义新的变量实现树之间的转换） 结语下一篇文章介绍人物控制器和鼠标控制镜头移动]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TPS射击游戏实战开发(一)]]></title>
    <url>%2F2017%2F07%2F30%2FTPS%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%2FTPS%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[资源准备 前言3D游戏开发，人物的模型是必不可少的，今天介绍两种获取模型的简单方法 体素模型简介 体素是体积元素(volumepixel)的简称，包含体素的立体可以通过立体渲染或者提取给定阈值轮廓的多边形等值面表现出来。一如其名，是数字数据于三维空间分割上的最小单位，体素用于三维成像、科学数据与医学影像等领域。概念上类似二维空间的最小单位——像素，像素用在二维计算机图像的影像数据上。有些真正的三维显示器运用体素来描述它们的分辨率，举例来说：可以显示512×512×512体素的显示器。 制作MagicaVoxel制作体素模型并不要求美术基础，使用 MagicaVoxel 软件可以满足我们的大部分需求，这里提供下载包 点击下载MagicaVoxel MagicaVoxel 使用方法界面首先了解一下这个软件的界面（连在一起的面版方便区别所以用黄红来分），如下图： MagicaVoxel使用教程，3D建模简单易学 MagicaVoxel使用教程，3D建模简单易学 工具1、直线工具 2、圆形工具，拖曳即可生成圆形 3.图样工具，先选择模型样式库里的模型，然后再选择这个工具在绘制对象的立体框中点击即可生成所选的模型样式库的对象（类似于PS自定义画笔，这里它是直接应用模型样式库里的对象，这里我暂且叫图样工具） 4.点状工具。点击一次就可生成一个方块单位的点，调它的广场数量可以绘制半球形； 5.面工具，每单击就可以创建以一方块为单位厚度的面； 6.矩形工具，拖拉即可框出一个以一个方块厚度的矩形对象； 7.创建（添加）、删除、上色、移动操作如下： 操作先说说操作，不需要键盘，没错就是不！需！要！键！盘！ 鼠标左键创建体素，滑轮键移动画面，右键转移视角，就是这么简单~ 最后一张图是这款软件的启动界面，最重要的就是左上角的Brush面板，L代表线，C代表圆，V是点，F是面，B是选框，Attach是创建，Erase是删除，Paint是上色，MOVE是移动，至于Mirror和Axis分别是按镜像和按轴心进行复制创建——听不懂也没关系啊，只用拿鼠标点一点知道了，而且LCVFB这几个选项，已经可以满足几乎所有的操作了。 与ADOBE软件相同，ctrl+z代表撤销，面板右上方的三个数字（45,45,45）代表着你可以支配的空间的大小，缺点是最大只能126,126,126,。所以清明上河图之类的东西是没法做咯，期待以后的版本更新。 面板坐下脚的Save和Open是保存和打开，记住这个文件正常的后缀是.vox哦，save下方是颜色模式，有HSV和RGB两种模式可以更换；右下角的Export是导出，可以导出obj、ply、mc等多种格式，也就是说，它不仅支持C4D而且也支持unity~ 建模完成后，点击上方name左边的render进入渲染模式，在light下面的选线大家应该一眼就能看明白了，依次是阴影、景深、太阳光、天光和FOG，也就是迷雾； 左边的matter也是提供了金属、玻璃和发光等一些效果供人选择，基本上已经满足了大多数人的渲染要求，在C4D或者MAX里需要花上很久的建筑模型，在MagicaVoxel也许只需要两三个小时就可以完成，可以说是一款有趣的，便捷的，小巧的神器。 点击转入原文 人物模型制作在制作人物模型时，你需要制作出这个人物的T-Pose 这是接下来为模型绑定骨骼所必须的 从Mixamo获取Mixamo简介2015年，Adobe收购了3D技术公司Mixamo，并推出3D建模软件Adobe Fuse CC以及增强了3D功能的Photoshop CC（现在都已经有预览版）。Fuse CC的3D建模和过去的3D软件从0开始的思路有很大差异，它提供了包括模型、材质、动画等等的极为丰富的3D模型数据库，用户只需在数据库中选择需要的部件进行组装，就可以创建自己的3D模型。Fuse CC也提供很多自定义属性，可以对模型进行个性化。 使用方法 点击转入Mixamo官网，因为是国外的网站可能会有点慢 1.Mixamo是Adobe旗下的公司，因此如果你想使用他的服务就必须先注册一个Adobe账号，注册时会要求你选择所在的国家或地区，这里记住不能选择CN(中国)，因为Adobe所谓的创意云不为中国地区提供任何互联网服务（我能怎么办我也很绝望啊 (｀皿´)ﾉ ）2.注册并登陆后选择 store 商店 3.紧接着你就可以看到这个页面 4.选择 Animation 挑选动画 Character 挑选人物模型，有许多免费的资源，对于我们学习来说是够用了 5.演示一下完整的获取流程 6.简单来说就是选择人物模型并选择匹配的动画，保存在My Assest文件中后你就可以下载了 7.U3D最常用的的模型有两类 .obj 和 .fbx，在下载时我们需要选择类型为 fbx for unity 绑定骨骼 这时候如果想为我们制作的体素模型添加动画的话，可以使用Mixamo的算法来进行骨骼的绑定（顺带一提 Mixamo中的模型都是绑定好骨骼的所以不需要额外的操作） 点选网站顶部的UPLOAD上传你的模型 按照图示要求，为头、手等关节处确定一个大致的范围，方便算法合成 （注意人物模型一定要制作成 T字型 不然算法不容易识别） 结语你可以选择自己制作体素模型或者是使用Mixamo的模型来为你的游戏准备资源，下一篇文章会将简单介绍U3D的动画系统]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D游戏开发预备课(终)]]></title>
    <url>%2F2017%2F07%2F29%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE-%E7%BB%88%2F</url>
    <content type="text"><![CDATA[常用知识点总结 --- 今天之后实战开发第三人称TPS游戏 知识点 本地坐标系： 只有拥有父物体的子物体才拥有的坐标系，一般的物体可以认为是只有世界坐标系 transform.forward/back/left/right 等属性，是基于世界坐标系(亦即时全局坐标系)与本地坐标系无关 四元数(quaternion)在3D程序中，通常用四元数来计算3D物体的旋转角度，与矩阵相比，四元数更加高效，占用的储存空间更小，此外也更便于插值 将本地坐标转化为世界坐标的方法：父物体Transform组件.transformPoint(子物体.localPosition); 明天开始实战开发 敬请期待！！！！]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D游戏开发预备课(九)]]></title>
    <url>%2F2017%2F07%2F27%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[常用工具类及物理射线 常用工具类静态类介绍 在面向对象的语言中有静态类的说法 静态类是被关键字 staitic 修饰的类，在程序编译后会自动创建 因此可以在静态类中实现一些静态方法直接用来调用，这种提供静态方法的静态类就是为程序编写提供方便的工具类 Mathf数学类 Mathf.Abs(float/int) —取绝对值 Mathf.Max(float,float) —取最大值 Mathf.Min(float,float) —取最小值 Mathf.Round(float) —四舍五入 Mathf.Lerp(float,float,float) —插值计算 Time时间类 Time.time —获得从游戏开始到现在经过的时间 Time.deltaTime —获得渲染完上一帧所花费的时间 Screen屏幕类 Screen.Width —获取游戏屏幕的宽度 Screen.height— 获取游戏屏幕的高度 物理射线U3D提供了一种物理射线可以与GameObject发生碰撞事件 射线相关属性及方法 Camera.main —是Tag标签为主摄像机的引用 Camera.ScreenPointToRay(Vector3) —将引入的点作为终点，以Camera为起点延伸出一条射线并返回 Physics.Raycast(Ray,out RaycastHit) — Physics工具类中的方法，判定指定的射线是否发生了碰撞，返回值为bool类型，并将被碰撞物体的信息记录到 RaycastHit 中 demo演示123456789101112131415161718192021222324252627282930313233using System.Collections;using System.Collections.Generic;using UnityEngine;public class RAY : MonoBehaviour &#123; private Camera m_camera; //用来存储碰撞物体的信息 private RaycastHit hit; //定义射线存储ScreenPointToRay返回的值 private Ray ray; void Start () &#123; //获取主摄像机的引用 m_camera = Camera.main; &#125; void Update () &#123; if (Input.GetMouseButtonDown(0)) &#123; //将当前鼠标点击的位置作为终点产生一条射线 ray = m_camera.ScreenPointToRay(Input.mousePosition); //Physics.Raycast(Ray,out RaycastHit) RaycastHit存储与射线发生碰撞物体的信息 if (Physics.Raycast(ray,out hit)) &#123; //销毁碰撞物体 Destroy(hit.collider.gameObject); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D游戏开发预备课(八)]]></title>
    <url>%2F2017%2F07%2F26%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[demo优化及协同程序简单介绍 显示分数 创建一个空物体添加GuiText组件并绑定脚本score 在score中实现一个增加分数的方法 123456789101112131415161718192021222324252627using System.Collections;using System.Collections.Generic;using UnityEngine;public class score : MonoBehaviour &#123; private GUIText m_guitext; private int Score; void Start () &#123; //获取到GUITEXT组件 m_guitext = gameObject.GetComponent&lt;GUIText&gt;(); //分数初始化 Score = 0; &#125; void Update () &#123; &#125; void AddScore() &#123; //增加分数 Score += 10; m_guitext.text = &quot;分数:&quot; + Score; &#125;&#125; 盒子销毁后随机出现金币 创建一个金币模型，并绑定脚本gold 在脚本中实现金币的自动旋转以及碰撞后销毁并增加得分 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;public class gold : MonoBehaviour &#123; //获取金币transform组件 private Transform m_t; //获取分数 private GameObject score; void Start () &#123; m_t = gameObject.GetComponent&lt;Transform&gt;(); score = GameObject.Find(&quot;score&quot;); &#125; void Update () &#123; //每一帧物体环绕世界的y轴旋转10度 m_t.Rotate(Vector3.forward,10f); &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.name == &quot;main&quot;) &#123; //销毁自身 Destroy(gameObject); score.SendMessage(&quot;AddScore&quot;); &#125; &#125;&#125; 这里出现了一个新的函数 “SendMessage(String)”,可以用来调用指定对象脚本中的方法 协同程序概念简介 在U3D游戏只有一个主线程，但是一个线程可以存在多个协同程序 协同程序不是线程但是类似于线程，主要区别在于线程是由系统控制的，而协程是由程序控制的 开启一个线程需要很大的性能开销而且需要考虑多个线程中资源的互斥访问问题 协程由程序控制，优点是性能开销小，但是在一个主线程内同时只能有一个协程在运行，其他协程必须暂停 协程只能在继承了MonoBehaviour的子类中使用 协程语法代码书写1234567 IEnumerator methodName(Object parameter1,Object parameter2,...)&#123;// to do somethingyield return YieldInstruction/other/null;// to do something else&#125;//协程必须返回一个 IEnumerator类型//yield return xxx 语句表示 等待 xxx完成后执行之后的语句 开启与关闭协程 StartCoroutine(IEnumerator routine);优点：灵活，性能开销小。缺点：无法单独的停止这个协程，如果需要停止这个协程只能等待协同程序运行完毕或则使用StopAllCoroutine();方法。 StartCoroutine (methodName:string, value : object = null);优点：可以直接通过传入协同程序的方法名来停止这个协程：StopCoroutine(string methodName);缺点：性能的开销较大，只能传递一个参数。 使用案例123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;public class test : MonoBehaviour &#123; void Start () &#123; Debug.Log(1); Debug.Log(2); //启动协程 StartCoroutine(&quot;task&quot;); Debug.Log(4); &#125; IEnumerator task() &#123; //等待两秒钟 yield return new WaitForSeconds (2); Debug.Log(3); &#125;&#125;]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D游戏开发预备课(七)]]></title>
    <url>%2F2017%2F07%2F25%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[U3D创建与销毁实例 ,Invoke定时函数及小demo实现 U3D游戏对象的实例化与销毁实例化准备工作–资源的导入在U3D中可以通过在脚本中定义 public 的 Gameobject对象来获取位于Assets资源文件夹中的资源文件，并用代码控制其生成定义以下 Gameobject 对象 可以方便的在检视面板(Inspector)中方便的进行资源的引用操作1public GameObject box; 要注意的是如果定义为 private 私有的话，检视面板就不能访问到从而无法进行资源的引入 实例化函数12345GameObject.Instantiate(GameObject,Vector3,Quaternion.identity);//GameObject: 资源的引用//Vector3: 生成后所处的位置//Quaternion: 四元数，用来表示物体的旋转情况//Quaternion.identity:无旋转 使用这个函数就可以在指定的位置生成引入的资源物体一般在开发中使用一个空物体绑定脚本实现游戏物体的创建与销毁 游戏物体销毁123GameObject.Destory(GameObject,float);//GameObject:要销毁对象的引用//float:销毁操作执行的延迟时间 gameObject是当前脚本所绑定对象的引用，因此可以将脚本绑定在要销毁的物体上时使用1GameObject.Destory(gameObject,float); 就可以完成当前对象的销毁 Invoke函数Invoke函数是U3D中的延时执行函数,相关的几个函数都继承自MonoBehaviour类 Invoke123Invoke(string,float);//string:要执行的函数名称//float:延时的时间 InvokeRepeating1234InvokeRepeating(string,float,float);//string:要执行的函数名称//第一个float:延时的时间//第二个float:第一次执行后过多长时间再次执行 与Invoke的区别在于Invoke只会执行一次，而InvokeRepeating会执行无数次直至被停止 CancelInvoke1CancelInvoke(); 直接调用会停止当前脚本的所有Invoke函数，无论是正在执行中还是处在计时状态 Demo实现使用上述的API实现盒子不断从空中掉落，玩家操作的物体碰撞到后将盒子销毁的Demo 盒子自动生成创建一个空物体并绑定以下脚本实现自动创建盒子:12345678910111213141516171819202122232425262728293031323334using System.Collections;using System.Collections.Generic;using UnityEngine;public class creatboxs : MonoBehaviour &#123; //外部资源的引用 public GameObject box; //盒子实时改变的位置 public Vector3 position; void Start () &#123; //定时自动执行创建盒子的方法 InvokeRepeating(&quot;AutoCreat&quot;, 1,1); &#125; void Update () &#123; //如果按下Z停止当前脚本所有的Invoke函数 if (Input.GetKeyDown(KeyCode.Z)) &#123; CancelInvoke(); &#125; &#125; //自动创建盒子 void AutoCreat() &#123; //使用Random.Range(min,max)随机生成盒子的位置 position = new Vector3(Random.Range(-10, 10), 20, Random.Range(-10, 10)); //使用该随机位置实例化盒子对象 Instantiate(box, position, Quaternion.identity); &#125;&#125; 玩家物体移动创建一个立方体添加刚体组件并绑定以下脚本实现角色控制:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using System.Collections;using System.Collections.Generic;using UnityEngine;public class character : MonoBehaviour &#123; //玩家控制物体刚体组件 private Rigidbody m_rigid; //玩家控制物体Transform组件 private Transform m_transform; void Start () &#123; //获取到当前游戏物体的刚体组件 m_rigid = gameObject.GetComponent&lt;Rigidbody&gt;(); //获取到当前游戏物体的Transform组件 m_transform = gameObject.GetComponent&lt;Transform&gt;(); &#125; void Update () &#123; //使用刚体移动方法 if (Input.GetKey(KeyCode.W)) &#123; m_rigid.MovePosition(m_transform.position+Vector3.forward*0.2f); &#125; if (Input.GetKey(KeyCode.A)) &#123; m_rigid.MovePosition(m_transform.position+Vector3.left * 0.2f); &#125; if(Input.GetKey(KeyCode.W) &amp;&amp; Input.GetKey(KeyCode.A)) &#123; m_rigid.MovePosition(m_transform.position + Vector3.Lerp(Vector3.forward * 0.2f, Vector3.left * 0.2f, 0.5f)); &#125; if (Input.GetKey(KeyCode.S)) &#123; m_rigid.MovePosition(m_transform.position+Vector3.back * 0.2f); &#125; if (Input.GetKey(KeyCode.S) &amp;&amp; Input.GetKey(KeyCode.A)) &#123; m_rigid.MovePosition(m_transform.position + Vector3.Lerp(Vector3.back * 0.2f, Vector3.left * 0.2f, 0.5f)); &#125; if (Input.GetKey(KeyCode.D)) &#123; m_rigid.MovePosition(m_transform.position+Vector3.right * 0.2f); &#125; if (Input.GetKey(KeyCode.S) &amp;&amp; Input.GetKey(KeyCode.D)) &#123; m_rigid.MovePosition(m_transform.position + Vector3.Lerp(Vector3.back * 0.2f, Vector3.right * 0.2f, 0.5f)); &#125; if (Input.GetKey(KeyCode.W) &amp;&amp; Input.GetKey(KeyCode.D)) &#123; m_rigid.MovePosition(m_transform.position + Vector3.Lerp(Vector3.forward * 0.2f, Vector3.right * 0.2f, 0.5f)); &#125; &#125;&#125; 碰撞销毁使用刚体碰撞事件监测并调用销毁函数:123456private void OnCollisionEnter(Collision collision) &#123; //为预制体添加box标签后通过该方法查找并销毁 if(collision.gameObject.tag==&quot;box&quot;) GameObject.Destroy(collision.gameObject); &#125;]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D游戏开发预备课(六)]]></title>
    <url>%2F2017%2F07%2F24%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[U3D声音组件的介绍及使用 简介 在U3D中所有导入的音乐资源统合为AudioClip类 U3D可以使用的音频格式为 .mp3 .aif .wav .ogg AudioClipU3D中的视频剪辑工具 工具面板: AudioSource用于播放音频的组件 创建 AudioSource 新建一个空对象 为空对象添加 AudioSource组件 常用属性 AudioClip 用于播放的导入文件 Play On Wake 如果勾选了这个选项在游戏开始时会自动的进行播放 Loop 如果勾选了这个选项会不停循环的播放 Mute 勾选之后AudioSource处于静音状态，但是播放还在继续 Volume 音量选项 设置值区间为 0—1 Spatial Blend (空间混合) 设置声音为2D或是3D Audio Listener 声音侦听器，用来接收Audio Source 播放的音频 如果Audio Source 设置为2D,就相当于广播，全局挂载着声音侦听器的Object都可以接收到声音信息 如果声音模式设置为3D 那么挂载着声音侦听器的Object与音源Audio Source 之间的距离就会影响到声音的大小 简而言之 3D模式的Audio Source 用来模拟现实场景中，人们可以听到近距离物体的响动，却听不到远处发出的声音 Audio Source 常用函数12345678910111213141516171819202122232425262728293031323334using System.Collections;using System.Collections.Generic;using UnityEngine;public class audiocontroller : MonoBehaviour &#123; /*定义Audio Source 类型的变量*/ private AudioSource m_audio; void Start () &#123; //获得当前的AudioSource组件 m_audio=gameObject.GetComponent&lt;AudioSource&gt;(); Debug.Log(m_audio); &#125; void Update () &#123; //输入z键播放音频 if (Input.GetKeyDown(KeyCode.Z)) &#123; m_audio.Play(); &#125; //输入x键暂停播放 if (Input.GetKeyDown(KeyCode.X)) &#123; m_audio.Pause(); &#125; //输入c键停止音频 if (Input.GetKeyDown(KeyCode.C)) &#123; m_audio.Stop(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D游戏开发预备课(五)]]></title>
    <url>%2F2017%2F07%2F22%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[U3D简单特效组件的介绍及使用 前言U3D自带的特效组件可以为不精通美术的开发者实现一些简单的特效 TrailRenderer简介 TrailRenderer,拖尾渲染器，作用是用于渲染显示“拖尾特效” 比如流星划过天空留下的轨迹，刀剑挥动产生的波纹，子弹的运动轨迹 拖尾在游戏中主要体现出物体的运动速度，增强真实感 创建拖尾特效 在Hierarchy面板新建一个空物体 选中空物体 选项卡 Component -&gt; Effects -&gt; Trall Renderer 添加特效组件 在 Scene 面板移动这个空物体的位置，就可以看到拖尾效果 要注意的是在U3D中所有的Renderer组件都需要设置材质球，如果没有设置材质球或者材质球丢失就默认为粉红色 制作透明材质球 在Project中右键创建一个Material 设置该材质球的 Shader 为 Particles(粒子) -&gt; Additive(添加物) 为该材质球设置贴图 ) 常用属性 Time 拖尾特效持续时间 Color 颜色 在unity5.5之后的版本中引入了一个曲线图来改变特效的起始宽度和终止宽度代替了原来的直接设置 操作方法： 双击红色线段上的任意点新建关键点 自由拖拽关键点设置特效的宽度变化曲线 改变曲线后的特效 LineRenderer简介 LineRenderer 线渲染器，作用是渲染显示线特效 可以用于表现枪支的红点瞄准等效果 创建线特效 在Hierarchy面板新建一个空物体 选中空物体 选项卡 Component -&gt; Effects -&gt; Line Renderer 添加特效组件 在 Scene 面板就可以看到线的效果 其它操作如赋予材质球和一些基本的属性与拖尾渲染器类似]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D游戏开发预备课(四)]]></title>
    <url>%2F2017%2F07%2F22%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[UI组件介绍及简单应用 前言在U3D开发中，有将近一半的工作量是实现游戏UI的界面及逻辑，因此选择一个好的UI开发工具有时能取得事半功倍的效果。在U3D中有以下几种UI开发工具可供选择： NGUI –大名鼎鼎的U3D第三方UI开发插件，可以高效的制作出精美的界面 UGUI – U3D官方从4.6版本开始自带的UI开发组件 ONGUI – 对UI界面的延伸与扩展，编写方式类似于web开发的html+css，并不是可视化编程 Lengcy UI – 旧版的UI只能实现简单的文本和图片操作，但是却是每个初学者必须学习的入门课程，是学习其它工具的过渡,也是本文章重点介绍的对象 下面介绍两个最基本的UI组件: GUI Text用来显示文本的组件 创建步骤 在Hierarchy面板中创建一个空物体 选中空物体 选项卡 Component -&gt; Rendering -&gt; GUI Text 完成组件的添加 要注意的是不论是何种组件在Scene面板中是不可见的，只能在Game面板中预览效果 基本属性 Text： 组件要显示的文本内容 Pixel Offset：(像素位移量) 通过改变位移量可以改变组件显示的位置 Font size：(字体大小)默认为0 Color： 文字的颜色 GUI Texture用来显示图片的组件 创建步骤 在Hierarchy面板中创建一个空物体 选中空物体 选项卡 Component -&gt; Rendering -&gt; GUI Texture 完成组件的添加 基本属性 Texture： 要引用的图片 Pixel Offset：(像素位移量) 通过改变位移量可以改变组件显示的位置 H W ：(图片的高度和宽度) Color：图片的颜色，修改此项会改变图片的色调 要注意的是修改图片的宽度与高度是在原图片的尺寸上进行加算，比如H值为100，原图片H值为100，则修改后图片的H值为200因此可以通过scale调节图片的缩放比例来改变原图片的宽和高 UI的鼠标事件UI的目的是了与用户的交互因此鼠标事件的引入必不可缺123OnMouseEnter() //鼠标进入事件OnMouseExit() //鼠标退出事件OnMouseDown() //鼠标点击事件 为GUI Text 添加如下脚本12345678910111213141516171819202122232425262728293031323334using System.Collections;using System.Collections.Generic;using UnityEngine;public class MouseEvent : MonoBehaviour &#123; private GUIText test; void Start () &#123; test = gameObject.GetComponent&lt;GUIText&gt;(); &#125; void Update () &#123; &#125; private void OnMouseEnter() &#123; test.color = Color.grey; &#125; private void OnMouseExit() &#123; test.color = Color.green; &#125; private void OnMouseDown() &#123; test.color = Color.blue; &#125;&#125; 效果展示：]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D游戏开发预备课(三)]]></title>
    <url>%2F2017%2F07%2F19%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[PC端游戏打包发布 简介通过打包发布可以将工程文件转换成独立的”游戏文件”，就可以脱离Unity引擎直接在PC上运行。 Unity 发布PC端游戏Build Setting[生成设置]File–&gt;Build Setting弹出项目生成面板 选择要发布到的平台 添加要发布的场景 Player Settings[详细设置] Company Name:公司名称 Product Name:产品名称 Default Icon:默认图标 成品文件 可执行文件 .exe 资源文件夹 Data双击可执行文件打开设置界面 默认以最高画质，最大屏幕尺寸运行点击play运行游戏 至此PC端游戏打包完成]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D游戏开发预备课(二)]]></title>
    <url>%2F2017%2F07%2F18%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[碰撞器和触发器的概念及相关处理事件 碰撞器碰撞器概念 在U3D引擎中任意物体之间的碰撞事件的产生都依赖于碰撞器，即“Collider”。 Object之间的碰撞实际上是“Collider”之间的碰撞。 Object所具有的网格渲染器，即”Mesh Renderer”并不参与碰撞的检测，仅仅是展现给人看的外观。 碰撞器所具有的属性 Material 材质 Is Trigger 是否触发器 Radius 半径(胶囊形或圆形碰撞器) Center 中心 Size 大小 在X、Y、Z三维上的碰撞器尺寸。 碰撞器事件123 1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器 2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器 3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器 实例只要为两个Object设置了碰撞器，就会继续碰撞检测。小方块与墙壁发生碰撞未能穿过墙壁。 触发器触发器概念 勾选碰撞器的”Is Trigger”属性,碰撞器就会变成触发器。 即原来具有这个碰撞器的Object现在不能发生碰撞。 触发器具有新的触发事件，在游戏中可以用来表示在特定的区域中发生的事件，如在毒雾中持续削减HP。 触发器所具有的属性 Material 材质 Is Trigger 是否触发器 Radius 半径(胶囊形或圆形触发器) Center 中心 Size 大小 在X、Y、Z三维上的碰撞器尺寸。 触发器事件123 1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器 2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器 3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器 实例将脚本添加到自己定义的空物体，并为空物体添加碰撞器，同时勾选”Is Trigger”,使用Edit Collider按钮调整区域大小小方块进入了指定区域，门自动打开 附实现完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System.Collections;using System.Collections.Generic;using UnityEngine;public class door : MonoBehaviour &#123; private Transform m_transform; void Start () &#123; //通过查找门的名称获取其变换组件 m_transform = GameObject.Find(&quot;doorparent&quot;).GetComponent&lt;Transform&gt;(); &#125; void Update () &#123; &#125; //开门方法 void Opendoor() &#123; m_transform.Rotate(Vector3.up, -90); &#125; //关门方法 void Closedoor() &#123; m_transform.Rotate(Vector3.up, 90); &#125; //当进入的物体为小方块 private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.name == &quot;student&quot;) &#123; Opendoor(); &#125; &#125; //当退出的物体为小方块 private void OnTriggerExit(Collider other) &#123; if (other.gameObject.name == &quot;student&quot;) &#123; Closedoor(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D游戏开发预备课(一)]]></title>
    <url>%2F2017%2F07%2F17%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE%2FUnity3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%84%E5%A4%87%E8%AF%BE-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[模型的中心点及模型的旋转 模型中心点说明模型身上的坐标轴中心点，也就是我们模型的中心点。模型的位置，旋转。缩放都是相对于模型的中心点来进行变化的。 如何改变模型中心点创建一个空物体，创建父子关系，通过父物体来控制子物体。也就间接的改变了模型的中心点。 实例模型的中心点是无法改变的，要实现门的旋转需要创建一个空物体作为门的父级，再将空物体移动到合适的位置作为中心点。通过空物体的旋转带动子物体门的旋转。 中心点工具Center:当选中两个模型的时候，设置为“Center”模型组的中心点就在两个模型的中间中心位置。Pivot:当选中两个模型的时候，设置为“Pivot”,模型组的中心点就在后选中的模型的中心点位置。tip:在Unity中按Ctrl键进行物体的加选。 使用键盘按键实现开关门使用Transform.Rotate(Vector3.float)旋转模型：Vector3:沿某个轴向旋转Float:旋转的参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.Collections;using System.Collections.Generic;using UnityEngine;public class door : MonoBehaviour &#123; private Transform m_transform; private bool isclose; // Use this for initialization void Start () &#123; //获取变换组件 m_transform = gameObject.GetComponent&lt;Transform&gt;(); isclose = true; &#125; // Update is called once per frame void Update () &#123; &#125; //角色在门的触发器范围内 private void OnTriggerStay(Collider other) &#123; //按下z键 if (Input.GetKeyDown(KeyCode.Z)) &#123; //如果门是关着的就打开 if (isclose) &#123; Opendoor(); isclose = false; &#125; //如果门是开着的就关闭 else &#123; Closedoor();isclose = true; &#125; &#125; &#125; //开门方法 void Opendoor() &#123; m_transform.Rotate(Vector3.up, 90); Debug.Log(&quot;kai&quot;); &#125; //关门方法 void Closedoor() &#123; m_transform.Rotate(Vector3.up, -90); Debug.Log(&quot;guan&quot;); &#125;&#125; 通过名称查找模型Gameobject静态类的静态方法Find（String）String:需要查找的模型名称返回值:gameobject对象1Gameobject.Find(name);]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>-游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右键菜单]]></title>
    <url>%2F2017%2F07%2F14%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[为网页添加右键菜单项 效果截图下面总结一下实现过程中遇到的坑点 延时函数js不像其他语言那样有专门的延时函数 “sleep(millions)”所以在做动画效果时，让CPU放慢处理频率从而显示流畅的动画效果就没那么方便。 在实现右键菜单的动画效果时，我用JS特有的setTimeout方法递归实现了 sleep的效果12345678910function loop_a(name,x,y)&#123; //满足条件进行移动操作 if(x&gt;=sx-60)&#123;m(name,x,y);setTimeout(function() &#123;loop_a(name,x-1,y-1);&#125; ,1) //间隔1ms &#125; else&#123; //递归结束 &#125;&#125; 获取鼠标位置12x=ev.clientX + document.body.scrollLeft - document.body.clientLeft,y=ev.clientY + document.body.scrollTop - document.body.clientTop 这个方法考虑到了页面过长时的滚动，在IE和谷歌浏览器上测试无误 完整实现代码直接引入这个js文件就可以实现 原浏览器右键功能封禁并增加新菜单的功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109$(document).ready(function()&#123; var c1=&quot;&lt;div onclick=&apos;c1_c()&apos; id=&apos;c1&apos; style=&apos;display:none;width:100px;height:100px;border-radius:50px;border:solid rgb(100,100,100) 1px;position:absolute;background-image:url(a.jpg)&apos;&gt;&lt;/div&gt;&quot;; var c2=&quot;&lt;div onclick=&apos;c2_c()&apos; id=&apos;c2&apos; style=&apos;display:none;width:100px;height:100px;border-radius:50px;border:solid rgb(100,100,100) 1px;position:absolute;background-image:url(b.jpg)&apos;&gt;&lt;/div&gt;&quot;; var c3=&quot;&lt;div onclick=&apos;c3_c()&apos; id=&apos;c3&apos; style=&apos;display:none;width:100px;height:100px;border-radius:50px;border:solid rgb(100,100,100) 1px;position:absolute;background-image:url(c.jpg)&apos;&gt;&lt;/div&gt;&quot;; var c4=&quot;&lt;div onclick=&apos;c4_c()&apos; id=&apos;c4&apos; style=&apos;display:none;width:100px;height:100px;border-radius:50px;border:solid rgb(100,100,100) 1px;position:absolute;background-image:url(d.jpg)&apos;&gt;&lt;/div&gt;&quot;; var c5=&quot;&lt;div onclick=&apos;c5_c()&apos; id=&apos;c5&apos; style=&apos;display:none;width:60px;height:60px;border-radius:50px; position:absolute;background-image:url(cha.png)&apos;&gt;&lt;/div&gt;&quot;; var sx=0; var sy=0; $(document.body).append(c1); $(document.body).append(c2); $(document.body).append(c3); $(document.body).append(c4); $(document.body).append(c5); &#125;);document.oncontextmenu = function() &#123; return false;&#125;$(document).mousedown(function(e)&#123; if(e.which==3)&#123; //圆心 $(&quot;#c5&quot;).css(&quot;display&quot;,&quot;none&quot;); var x=e.clientX; var y=e.clientY; var cx=x-50; var cy=y-50; $(&quot;#c5&quot;).css(&quot;left&quot;,cx+20); $(&quot;#c5&quot;).css(&quot;top&quot;,cy+20); sx=cx;sy=cy; loop_a(&quot;c1&quot;,cx,cy); loop_b(&quot;c2&quot;,cx,cy); loop_c(&quot;c3&quot;,cx,cy); loop_d(&quot;c4&quot;,cx,cy); &#125;&#125;);function c1_c()&#123; window.location.href=&apos;http://www.baidu.com&apos;;&#125;function c2_c()&#123; window.location.href=&apos;http://www.baidu.com&apos;;&#125;function c3_c()&#123; window.location.href=&apos;http://www.baidu.com&apos;;&#125;function c4_c()&#123; window.location.href=&apos;http://www.baidu.com&apos;;&#125;function c5_c()&#123; $(&quot;#c1&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;#c2&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;#c3&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;#c4&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;#c5&quot;).css(&quot;display&quot;,&quot;none&quot;);&#125;function m(name,offsetx,offsety)&#123; $(&quot;#&quot;+name+&quot;&quot;).css(&quot;left&quot;,offsetx); $(&quot;#&quot;+name+&quot;&quot;).css(&quot;top&quot;,offsety); $(&quot;#&quot;+name+&quot;&quot;).css(&quot;display&quot;,&quot;&quot;);&#125;function loop_a(name,x,y)&#123; if(x&gt;=sx-60)&#123;m(name,x,y);setTimeout(function() &#123;loop_a(name,x-1,y-1);&#125; ,1) &#125; else&#123; &#125;&#125;function loop_b(name,x,y)&#123; if(x&lt;=sx+60)&#123;m(name,x,y);setTimeout(function() &#123;loop_b(name,x+1,y-1);&#125; ,1) &#125; else&#123; $(&quot;#c5&quot;).css(&quot;display&quot;,&quot;&quot;); &#125;&#125;function loop_c(name,x,y)&#123; if(x&gt;=sx-60)&#123;m(name,x,y);setTimeout(function() &#123;loop_c(name,x-1,y+1);&#125; ,1) &#125; else&#123; &#125;&#125;function loop_d(name,x,y)&#123; if(x&lt;=sx+60)&#123;m(name,x,y);setTimeout(function() &#123;loop_d(name,x+1,y+1);&#125; ,1) &#125; else&#123; &#125;&#125;]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>-杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的优化]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[博客的优化 个性域名的绑定想要给你的博客绑定个性域名，首先需要购买域名，这里推荐 腾讯云购买（好像有点打广告的嫌疑 |ω･`)暗中观察）购买之后首先要给你的域名添加两个解析 一个CNAME类型的记录指向你的GitHub域名一个A类型的记录也是指向GitHub域名，只不过这里应该是主机地址，我们可以在cmd中用ping yourname.github.io来获取主机地址设置完成后返回你的GitHub项目主页在GitHub page 中的最后一项填入你的域名完成域名的绑定 写文章gitBash进本地项目1hexo new &quot;新文章的题目&quot; 使用这个命令新建文章新建的文章存放在 /source/_posts中 使用markdown标记语言来编写你的文章，相关的语法可以再百度中搜索要注意的是如果出现乱码，则需要将文件的后缀名改为.txt另存为UTF-8的格式 部署文章的方法和之前的一样1hexo clean &amp;&amp; hexo d 部署的速度基于你文件变化的多少，一般来说一片新文章也就几秒钟，很快的 ฅ( ̳• ·̫ • ̳) 喵 图片加载优化在使用markdown语言写文章时有时会用到图片，因为GitHub是国外的网站，经常会出现文章都快看完了，图片还没加载出来的尴尬场面 (((;꒪ꈊ꒪;))震惊我们可以使用国内的第三方网站来存储我们的图片资源，这样加载这里推荐使用七牛云（我真的没有在打广告 ゞ(o｀Д´o) 来打架啊！）百度七牛云，因为和GitHub有合作所以可以直接使用GitHub账号登录之后在你的主页 添加对象存储 可以免费获得10g的空间在内容管理中可以上传你的图片点击右侧的复制外链，就可以在你的文章中引用此链接来快速的加载图片啦！(◕ᴗ◕✿)]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>-杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Hexo+github搭建个人网站的总结]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F%E5%88%A9%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[花了两天的时间搭建了个人网站，记录一下搭建过程中踩过的坑，供今后参考。 前言很多人都想要一个自己的博客网站，但奈何技术有限，条件有限。搭建网站需要服务器、域名、DNS服务器等一大堆令人头疼的条件。但是如果给你一个机会不需要太高的web开发技术就能DIY属于你自己的独立网站，你愿不愿意呢？|ω･`)暗中观察 利用Hexo搭建静态网页Hexo是什么？Hexo是一个开源的静态博客生成器,用node.js开发,作者是台湾大学生tommy351。 静态博客编译之后是纯html页面,优点就是支持它的环境十分好找,例如github、gitcafe、七牛云存储等站点都支持静态页面托管,自然是我们的首选了。由于github page在国内访问较慢,这篇文章用gitcafe做示范。gitcafe是天朝本地化的github,同样提供展示页和域名绑定功能,不需要备案,就是爽。 但是静态博客并非没有缺点。动态博客更新文章时,脚本是不变的,只需要更新数据库。静态博客要频繁改动文件,不&gt;支持增量式上传的东西,比如ftp,就难于管理。此外,还要十分熟悉git各种命令,才能部署页面。 总接一下使用Hexo的方便之处： 静态网页的加载速度快。 支持github gitcafe 等开源网站进行代码、资源的免费托管省去了服务器的开销。 开源网站提供了免费的域名，如果你想要自己的个性域名也可以自己购买并设置（在文章的后面会讲到）。 Hexo有许多丰富的主题，你可以在对主题的配置文件熟悉后随意的DIY。 ฅ( ̳• ·̫ • ̳) 喵 Hexo的配置环境配置下面进入正题 (oﾟ▽ﾟ)o首先你要进行Hexo的配置。因为Hexo是由Node.js编写的所以你在配置Hexo前还需要安装Node.js的环境还要安装git工具控制网站的版本，Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 下面提供了64位安装包的链接，如果你的机器是32位的 （(宝ᴗ宝)不信你现在还在用32位的电脑）请自行百度下载Hexo配置安装包-64安装过程很简单，一路next就行了安装完成后 使用win+R打开cmd控制台输入以下指令查看git 和 node.js的版本123node -vnpm -vgit --version 如果出现版本信息则安装成功，进入下一步 ฅ( ̳• ·̫ • ̳) 喵 Hexo安装在cmd控制台中输入以下指令1npm install hexo-cli -g 再输入1hexo -v 查看版本号，如果出现版本信息，那么至此Hexo的本地配置已经完成了 ฅ( ̳• ·̫ • ̳) 喵 生成本地网页在任意目录下新建一个文件夹，我命名为test，然后右键选择 Git Bash Here 使用指令1hexo -init 进行Hexo的初始化操作，可能等待的时间比较长初始化操作完成后会出现 “Start blogging with Hexo!”的欢迎语之后执行指令1hexo -s 开启本地服务器 它会返回一个地址提醒你拷贝到浏览器上去访问注意这里不能使用Ctrl+c Ctrl+v进行复制粘贴，因为在git中Ctrl+c是停止的意思（很坑有木有 ( ´~` )）这里只能老老实实用鼠标右键进行复制粘贴操作把链接复制到浏览器的地址栏上哇，这是不是很神奇，我们本地的静态网页就配置好了 ฅ( • ·̫ • ) 喵 如何进行DIY这个界面是不是不怎么样，不够高端大气上档次，那我们该怎么样modify成我们喜欢的风格呢打开刚才创建的文件夹，我的是 test里面有一个”_config.yml“的配置文件 右键用记事本打开1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexosubtitle:description:author: John Doelanguage:timezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 哇，这是什么东西快扶朕起来 o(ﾟДﾟ)っ！不要着急让我们一步步的分析，总共只有两个部分是我们上传代码必须要进行配置的1234567891011# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: site配置之后讲到上传代码的时候会详细讲一下这两块的配置现在主要配置这两项123456789101112# Sitetitle: Hexosubtitle:description:author: John Doelanguage:timezone:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 首先Site部分设置博客的标题、副标题、描述、作者和使用的语言这里可以自行设置，设置language时要注意一下中文对应的代码是：zh-Hans操作完成后别忘记save一下，然后 hexo-s开启本地服务器查看一下效果1hexo -s 这条指令的完整写法是 hexo -server今后我们写文章时在本地可以预览之后再发布到GitHub上 theme配置我们可以在GitHub上搜索合适的主题copy到当前项目目录下的themes文件中这里我直接使用代码进行下载1git clone https://github.com/iissnan/hexo-theme-next themes/next 之后就很简单了，我们只需要 配置文件中的 theme: landscape 变成 theme: next(这是我下载的主题名)部署本地服务器看一下效果吧不同的主题也有自己的配置文件，大家可以自己百度搜索合适你的主题及配置方法，我这里就不多说了熟悉主题之后，我们可以自己修改 css样式 javascript源码打造你自己的博客！ (◕ᴗ◕✿) 将Hexo生成的静态网页发布到GitHub上注册GitHub账号并新建一个项目博客可不光光是用来给自己看的，我们还要部署到网络中与千千万万的同胞分享 (((;꒪ꈊ꒪;))百度搜索GitHub注册一个账号，登陆后点击右上角的加号 选择 “Create a new repository ”在“Repository name”中填入你的用户名，注意这里的名称一定要与前面的 owner的名称一致 不然你就无法通过 yourusername.github.io 的方式 访问你的博客了，也会给之后的配置造成麻烦接着勾选“Initialize this repository with a README”完成创建 (◕ᴗ◕✿) 配置文件的修改之前的配置文件有两处是上传必需修改的1234567891011# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 第一项 URL 按我的步骤走下来的话，只需要修改其中的 url将它修改为这样的形式：http://+你刚刚创建的GitHub用户名+github.io第二项 Deployment需要修改成以下格式12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: https://github.com/zzchong2233/zzchong2233.github.io.git type: git branch: master 其中deploy的地址其实就是你刚刚新建的项目地址，复制过来就行我们之后的操作就是将本地的代码上传到这个地址并在 指定的url解析出来嗯，大致这两步设置就是这个意思 (oﾟ▽ﾟ)o 上传本地代码网上有许多上传的方法，可能是版本更新的问题导致好多方法我测试的时候都不起作用，这里介绍一种我总结出来的方法，没有那么多的步骤，但满足了基本的需求。gitbash到本地的项目1hexo -clean &amp;&amp; hexo -d 清理缓存并发布到deploy的地址第一次发布时会弹出一个窗口，输入你的GitHub账号密码即可然后就是上传，这时候就要看你的网速了，由于GitHub是国外网站所以上传速度可能是时快时慢输入完账号后可能出现提示消息 “tell me who you are”然后会提示你运行两条指令，先不用管等上传结束后再copy一下这两条命令（原样复制粘贴运行就行了不要做多余的操作）之后上传的时候就不会有这条警告了 设置GitHub Pages登录到你的项目地址，在上方有一个setting按钮往下翻 有一项 GitHub Pages点选第一个source下拉框 里面应该只有一个分支 master 选中之后保存稍等一会，在浏览器的地址栏中输入你的域名 name.github.io 就可以看到你DIY的blog了 ฅ( ̳• ·̫ • ̳) 喵 总结下一篇文章会谈谈怎样编写文章并发布，如何优化图片资源的加载速度，如何把GitHub的域名绑定到你自己的域名]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>-杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客开通]]></title>
    <url>%2F2017%2F07%2F10%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A%2F</url>
    <content type="text"><![CDATA[纪念一下!]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>-杂谈</tag>
      </tags>
  </entry>
</search>